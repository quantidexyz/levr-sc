---
alwaysApply: true
---
## Levr Protocol v1 — Contracts Architecture

This document defines the contract architecture and implementation details for Levr Protocol v1, focusing on the modular contract system with factory, treasury, governor, and wrapper components. It is the source-of-truth for contract implementations and integration decisions.

### Scope and Compatibility

- **Protocol version**: v1
- **Compatibility**: Not backward compatible with v1. v1 uses a modular architecture with separate contracts for treasury, governance, and token wrapping.
- **Architecture**: Modular system with `LevrFactory_v1` as the entry point, deploying per-project `LevrTreasury_v1`, `LevrGovernor_v1`, and `LevrERC20` wrapper contracts.

---

### Core Contract Entities

#### LevrFactory_v1

- **Role**: Global configuration owner and deployment/registry entrypoint for projects
- **Responsibilities**:

  - Deploy/clone per-project contracts (`LevrTreasury_v1`, `LevrGovernor_v1`, `LevrERC20`)
  - Manage protocol-wide configuration (fees, limits, tiers, deadlines)
  - Register projects with optional treasury reuse

- **Key Storage**:
  - `protocolFeeBps`: Fee in basis points for mint/redeem operations
  - `projectFeeBpsOfProtocolFee`: Share of protocol fee going to project treasury
  - `submissionDeadlineSeconds`: Proposal deadline (default 7 days)
  - `maxSubmissionPerType`: Max proposals per type per 7-day window
  - `stakingBoostTiers`, `transferTiers`: Governance tier configurations
  - `minWTokenToSubmit`: Minimum wrapper balance to submit proposals
  - `protocolTreasury`: Protocol fee recipient address
  - Contract implementation addresses for cloning

#### LevrTreasury_v1 (Per-Project)

- **Role**: Custody and execution contract for project assets and governance decisions
- **Responsibilities**:

  - Hold underlying reserve tokens and fee receipts
  - Execute transfers and boost applications authorized by governor
  - Handle wrap/unwrap operations with fee collection
  - Receive and manage Clanker fee emissions

- **Key Storage**:
  - `underlying`: Address of the Clanker token
  - `governor`: Address of the project's governor contract
  - `wrapper`: Address of the project's wrapper token
  - Fee collection balances and accounting

#### LevrGovernor_v1 (Per-Project)

- **Role**: Governance and proposal execution for project treasury decisions
- **Responsibilities**:

  - Handle proposal submissions (transfer requests, staking boosts)
  - Enforce submission limits, deadlines, and tier constraints
  - Execute approved proposals on the treasury

- **Key Storage**:
  - Active proposals with metadata (type, amounts, deadlines, tiers)
  - Rolling counters for submission rate limiting
  - Proposal execution state and voting records

#### LevrERC20 (Per-Project Wrapper)

- **Role**: 1:1 wrapper token for the underlying Clanker token with fee mechanics
- **Responsibilities**:

  - Mint wrapper tokens upon deposit of underlying (minus fees)
  - Redeem underlying tokens upon burn of wrapper (minus fees)
  - Maintain 1:1 peg with underlying decimals and supply semantics

- **Key Storage**:
  - Mirrors underlying token decimals
  - Total supply tracking for governance requirements
  - Standard ERC20 balances and allowances

---

### Contract Interactions and Flow

#### Project Registration

1. **External Call**: `LevrFactory_v1.register(clankerToken, params)`

   - `params.treasury`: Optional existing treasury address
   - Validates clankerToken exists and is properly configured

2. **Contract Deployment**:

   - If `params.treasury` provided: Use existing treasury, validate ownership
   - Otherwise: Deploy new `LevrTreasury_v1` via clone/factory pattern
   - Deploy `LevrGovernor_v1` with treasury as execution target
   - Deploy `LevrERC20` wrapper with treasury as fee recipient

3. **Initialization**:
   - Treasury: Set governor, wrapper, underlying addresses
   - Governor: Set treasury address and factory config reference
   - Wrapper: Grant minter/burner roles to treasury

#### Wrap/Unwrap Operations

**Mint (Wrap)**:

```
User → Underlying.transfer(treasury, amount)
Treasury → calculateFees(amount) → deduct fees
Treasury → Wrapper.mint(user, amount - fees)
```

**Redeem (Unwrap)**:

```
User → Wrapper.burn(treasury, amount)
Treasury → calculateFees(amount) → deduct fees
Treasury → Underlying.transfer(user, amount - fees)
```

Fee Split: Protocol treasury gets `protocolFeeBps` share, project treasury gets remaining fee portion.

#### Governance Proposals

**Proposal Creation**:

- Validate `msg.sender` holds ≥ `minWTokenToSubmit` wrapper tokens
- Check rolling submission limits per type (7-day windows)
- Validate amount constraints against selected tier
- Store proposal with deadline (`block.timestamp + submissionDeadlineSeconds`)

**Proposal Execution**:

- Verify proposal deadline not exceeded
- Execute treasury action based on proposal type
- Update rolling counters and emit events

---

### Fee Model and Accounting

#### Mint/Redeem Fees

- **Protocol Fee**: `protocolFeeBps / 10000` of operation amount
- **Project Fee**: `projectFeeBpsOfProtocolFee / 10000` of protocol fee
- **Fee Split**:
  - Protocol treasury: `protocolFee - projectFee`
  - Project treasury: `projectFee`

#### Rounding and Precision

- Use conservative rounding favoring reserves safety
- Track fee accumulations in project treasury for governance distribution
- Emit fee collection events for transparency

#### Invariants

- Wrapper total supply ≤ underlying balance in treasury (accounting for collected fees)
- Fee collections properly split between protocol and project treasuries
- Governance proposals execute atomically with proper access controls

---

### Governance: Submission Limits and Tiers

#### Global Configuration (Factory Level)

- `submissionDeadlineSeconds: uint32` — Common deadline for all proposal types (default: 604,800 = 7 days)
- `maxSubmissionPerType: uint16` — Max proposals per type per rolling 7-day window
- `minWTokenToSubmit: uint256` — Minimum wrapper balance required to submit proposals

#### Tier Definitions

**Transfer Tiers** (absolute amounts in underlying units):

- `low`, `mid`, `high`: Maximum transfer amounts per proposal

**Staking Boost Tiers** (fraction of treasury or emissions):

- `low`, `mid`, `high`: Boost percentages (e.g., 0.03, 0.6, 0.9)

#### Rolling Window Enforcement

- Track submissions per `(projectId, proposalType, weekStart)` mapping
- Use `block.timestamp / 604800` for week calculation
- Revert if `currentCount >= maxSubmissionPerType`

---

### Security Considerations

#### Access Control

- **Factory**: Only owner can update global configuration
- **Treasury**: Only governor can execute transfers and boosts
- **Governor**: Only wrapper holders meeting minimum balance can propose
- **Wrapper**: Treasury has exclusive mint/burn rights

#### Reentrancy Protection

- Non-reentrant guards on all external treasury functions
- Wrap/unwrap operations use checks-effects-interactions pattern
- Fee calculations completed before token transfers

#### Input Validation

- All addresses validated as non-zero
- Amounts checked against tier limits and balance availability
- Deadline calculations prevent overflow/underflow

#### Emergency Controls

- Factory owner can pause registrations if needed
- Treasury includes emergency withdrawal mechanisms (governance-controlled)
- Wrapper includes optional pauser role for extreme circumstances

---

### Contract Interfaces (Implementation Requirements)

#### LevrFactory_v1

```solidity
interface ILevrFactory_v1 {
    function register(
        address clankerToken,
        RegisterParams calldata params
    ) external returns (address governor, address wrapper);

    function updateConfig(FactoryConfig calldata cfg) external;

    function getProjectContracts(address clankerToken)
        external view returns (address treasury, address governor, address wrapper);
}

struct RegisterParams {
    address treasury; // optional: reuse existing treasury
    bytes extraConfig; // future extension data
}

struct FactoryConfig {
    uint16 protocolFeeBps;
    uint16 projectFeeBpsOfProtocolFee;
    uint32 submissionDeadlineSeconds;
    uint16 maxSubmissionPerType;
    TierConfig[] transferTiers;
    TierConfig[] stakingBoostTiers;
    uint256 minWTokenToSubmit;
    address protocolTreasury;
}
```

#### LevrTreasury_v1

```solidity
interface ILevrTreasury_v1 {
    function wrap(uint256 amount, address to) external returns (uint256 minted);
    function unwrap(uint256 amount, address to) external returns (uint256 returned);

    function transfer(address to, uint256 amount) external;
    function applyBoost(uint256 amount) external;

    function collectFees() external; // from Clanker emissions

    function getUnderlyingBalance() external view returns (uint256);
    function getCollectedFees() external view returns (uint256);
}
```

#### LevrGovernor_v1

```solidity
interface ILevrGovernor_v1 {
    function proposeTransfer(
        address receiver,
        uint256 amount,
        string calldata reason,
        uint8 tier
    ) external returns (uint256 proposalId);

    function proposeBoost(
        uint256 amount,
        uint8 tier
    ) external returns (uint256 proposalId);

    function execute(uint256 proposalId) external;

    function getProposal(uint256 proposalId)
        external view returns (Proposal memory);

    function canSubmit(address proposer) external view returns (bool);
}

struct Proposal {
    address proposer;
    ProposalType proposalType;
    address receiver;
    uint256 amount;
    string reason;
    uint8 tier;
    uint32 deadline;
    bool executed;
}
```

#### LevrERC20

```solidity
interface ILevrERC20 is IERC20 {
    function mint(address to, uint256 amount) external;
    function burn(address from, uint256 amount) external;

    function decimals() external view returns (uint8);
    function underlying() external view returns (address);
}
```

---

### Implementation Patterns and Best Practices

#### Contract Deployment

- Use minimal proxy (ERC-1167) clones for gas-efficient deployment
- Initialize contracts with immutable references to avoid storage costs
- Validate all constructor parameters and relationships

#### Storage Optimization

- Pack related variables into single slots where possible
- Use mappings for per-user/project data to avoid iteration
- Cache frequently accessed factory config in governor contracts

#### Event Emission

- Emit comprehensive events for all state changes
- Include indexed parameters for efficient off-chain querying
- Follow ERC-20/ERC-721 event standards where applicable

#### Error Handling

- Use custom errors instead of string reverts for gas efficiency
- Provide descriptive error messages for debugging
- Validate inputs at function boundaries

---

### Testing Guidance (Contract-Focused)

#### Unit Tests

- Test all fee calculations and edge cases (rounding, overflow)
- Validate tier enforcement and submission limits
- Test proposal lifecycle (create → execute → cleanup)
- Verify access controls and permission boundaries

#### Integration Tests

- End-to-end wrap/unwrap flows with fee collection
- Governance proposal creation and execution
- Multi-project registration and isolation
- Emergency controls and pause functionality

#### Invariant Tests

- Wrapper supply never exceeds treasury underlying balance
- Fee collections properly accounted and split
- Governance proposals execute atomically
- Rolling counters accurately track submission limits

#### Fuzz Tests

- Random fee configurations and tier selections
- Arbitrary proposal amounts and deadlines
- Concurrent operations and reentrancy attempts
- Edge case amounts (0, max uint256, etc.)

---

### Migration and Deployment Notes

- **From v1**: No automatic migration path; v1 requires fresh deployment
- **Contract Verification**: All contracts should be verified on deployment networks
- **Proxy Patterns**: Consider upgradeable proxies for critical infrastructure contracts
- **Initialization**: Ensure proper initialization order and validation

---

This rule is normative for contract implementations. All contract code should align with the above specifications. Any architectural changes should update this document first.

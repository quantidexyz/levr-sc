---
alwaysApply: true
---

## Levr Protocol v1 — Architecture Guide

Source-of-truth for Levr Protocol v1 contracts. Modular system: Factory deploys per-project Treasury, Governor, Staking, and StakedToken.

### Architecture

```
LevrFactory_v1
  ↓ prepareForDeployment() → (treasury, staking)
  ↓ register(clankerToken) → Project{treasury, governor, staking, stakedToken}
```

## Contracts

### LevrFactory_v1 (Singleton)

**Role**: Registry and deployment coordinator

**Functions**:

- `prepareForDeployment()` → Deploy treasury & staking, return addresses
  - Anyone can call; stores `deployer → PreparedContracts`
  - Call BEFORE Clanker deployment to get addresses
- `register(clankerToken)` → Complete setup, return `Project` struct
  - Only `clankerToken.tokenAdmin()` can call
  - Auto-uses prepared contracts from `msg.sender` (or deploys new)
  - Returns `Project{treasury, governor, staking, stakedToken}`
- `getProjectContracts(clankerToken)` → Query registered project

**Security**: Only deployer can use their prepared contracts; only tokenAdmin can register

---

### LevrTreasury_v1

**Role**: Asset custody (NOT Ownable - governor controls)

**Functions**:

- `transfer(to, amount)` → Governor-authorized transfer
- `applyBoost(amount)` → Move to staking, accrue rewards

**Access**: `onlyGovernor` modifier

---

### LevrGovernor_v1

**Role**: Governance and proposals

**Functions**:

- `proposeTransfer(receiver, amount, reason, tier)`
- `proposeBoost(amount, tier)`
- `execute(proposalId)`

**Validation**: Min staked balance, tier limits, rolling windows, deadlines

---

### LevrStaking_v1

**Role**: Stake escrow, multi-token rewards

**Functions**:

- `stake(amount)`, `unstake(amount, to)` → Mint/burn stakedToken 1:1
- `accrueRewards(token, amount)` → Delta-based accrual
- `accrueFromTreasury(token, amount, pull)` → Boost from treasury
- `claimRewards(tokens[], to)` → Multi-token claim

**Reward Paths**:

1. ERC-1363 auto-credit (`onTransferReceived`)
2. Governor boost → `treasury.applyBoost` → `staking.accrueFromTreasury`
3. Manual `accrueRewards`

**Safety**: Reserve tracking, liquidity checks, streaming windows

---

### LevrStakedToken_v1

**Role**: 1:1 staked representation, governance weight

**Access**: Only staking can mint/burn

## Deployment Flow

### Complete Workflow

```solidity
// 1. Prepare (get addresses before Clanker exists)
(address treasury, address staking) = factory.prepareForDeployment();

// 2. Deploy Clanker token
// - Set treasury as airdrop recipient → receives initial allocation
// - Set staking as LP fee recipient → receives ongoing trading fees

// 3. Register (as tokenAdmin)
ILevrFactory_v1.Project memory project = factory.register(clankerToken);
// Access: project.treasury, project.governor, project.staking, project.stakedToken
```

### Initialization Sequence

1. Treasury & Staking deployed via `prepareForDeployment()`
2. Clanker token deployed (uses treasury/staking addresses)
3. `register()` deploys governor & stakedToken, initializes all contracts
4. Governor set as treasury controller, staking linked to treasury

---

## Core Flows

### Staking

```
User stakes → Staking escrows underlying, mints stakedToken 1:1
User unstakes → Staking burns stakedToken, returns underlying
```

### Rewards

```
Clanker LP fees → Staking (auto-accrues via ERC-1363)
Clanker airdrops → Treasury
Governor proposes boost → Treasury.applyBoost(amount)
Treasury → Staking.accrueFromTreasury (measures delta, credits immediately)
Users claim → Multi-token claim with reserve checks
```

### Governance

```
User (with minWTokenToSubmit) → proposeTransfer or proposeBoost
Validates: tier limits, rolling windows, deadlines
Execute → Treasury performs action (transfer or boost)
```

## Data Structures

```solidity
struct Project {
  address treasury;
  address governor;
  address staking;
  address stakedToken;
}

struct PreparedContracts {
  address treasury;
  address staking;
}
```

---

## Security

### Access Controls

| Function                         | Who Can Call                           |
| -------------------------------- | -------------------------------------- |
| `factory.prepareForDeployment()` | Anyone (tracked by deployer)           |
| `factory.register()`             | Only `clankerToken.tokenAdmin()`       |
| `treasury.transfer/applyBoost()` | Only governor                          |
| `governor.propose*()`            | Anyone with `minWTokenToSubmit` staked |
| `staking.stake/unstake/claim()`  | Anyone                                 |
| `stakedToken.mint/burn()`        | Only staking                           |

### Protections

- **Reentrancy**: Guards on all treasury/staking external functions
- **Double Registration**: Prevented via `ALREADY_REGISTERED` check
- **Front-running**: Only deployer can use their prepared contracts
- **Reward Safety**: Reserve tracking prevents overdraw
- **No Owner on Treasury**: Governor controls all operations

### Invariants

- StakedToken supply == total underlying staked
- Reward reserves >= pending claims
- One project per clankerToken
- Prepared contracts only usable by deployer

## Configuration

### Factory Config

- `protocolFeeBps` — Protocol fee (basis points)
- `submissionDeadlineSeconds` — Proposal deadline (7 days default)
- `streamWindowSeconds` — Reward streaming (3 days default)
- `minWTokenToSubmit` — Min staked to propose
- `transferTiers[]` — Max transfer amounts (low, mid, high)
- `stakingBoostTiers[]` — Max boost percentages

### Tiers

**Transfer**: Absolute amounts per proposal  
**Boost**: Percentage of treasury balance

---

## Code Patterns

### Registration

```solidity
// Factory setup
LevrFactory_v1 factory = new LevrFactory_v1(config, owner);

// Prepare before Clanker
(address treas, address stak) = factory.prepareForDeployment();

// Deploy Clanker (use treas & stak addresses)

// Register
ILevrFactory_v1.Project memory p = factory.register(clankerToken);
```

### Accessing Components

```solidity
ILevrFactory_v1.Project memory proj = factory.getProjectContracts(token);

LevrTreasury_v1(payable(proj.treasury));
LevrGovernor_v1(proj.governor);
LevrStaking_v1(proj.staking);
LevrStakedToken_v1(proj.stakedToken);
```

---

## Testing

**Must Cover**:

- Security: Access controls, deployer tracking
- Flows: Stake → Boost → Claim → Unstake
- Governance: Proposals, tiers, execution
- Rewards: Multi-token, reserves, streaming
- Edge cases: Zero amounts, double registration, unauthorized calls

## Key Design Decisions

### Why No CREATE2 / Deterministic Addresses?

- **prepareForDeployment**: Simple `new Contract()` - no salting
- **register**: Deploys governor/stakedToken without salts
- **Reason**: Addresses don't need prediction - treasury/staking exist before Clanker

### Why No Ownable on Treasury?

- **Governor controls all operations** via `onlyGovernor` modifier
- **Register is gated** by `tokenAdmin` check - no front-running
- **Simpler, cleaner** - one less security layer to manage

### Why Auto-Lookup of Prepared Contracts?

- **Mapping tracks deployer** → `PreparedContracts{treasury, staking}`
- **register() auto-uses** prepared contracts from `msg.sender`
- **Security**: Only deployer can use their contracts (no parameters to hijack)

### Why Return Project Struct?

- **Cleaner API**: One struct vs four separate addresses
- **Type safety**: All addresses grouped logically
- **Easier usage**: `proj.treasury` vs destructuring

---

## Changes from Previous Versions

### Removed

- ❌ `registerDryRun()` - unreliable prediction
- ❌ CREATE2 salting - not needed
- ❌ Treasury `Ownable` - redundant
- ❌ Multiple return values - now returns struct
- ❌ Treasury/staking params in register - auto-lookup

### Added

- ✅ `prepareForDeployment()` - pre-deploy infrastructure
- ✅ Deployer tracking - security via mapping
- ✅ `Project` struct returns - cleaner API
- ✅ Auto-lookup prepared contracts
- ✅ Treasury receives airdrops, Staking receives fees (split roles)

---

**This rule is normative. All contract code must align with these specifications.**

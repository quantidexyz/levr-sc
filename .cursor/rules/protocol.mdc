---
alwaysApply: true
---

## Levr Protocol v1 — Contracts Architecture

This document defines the contract architecture and implementation details for Levr Protocol v1, focusing on the modular contract system with factory, treasury, governor, staking module, and staked token components. It is the source-of-truth for contract implementations and integration decisions.

### Scope and Compatibility

- **Protocol version**: v1
- **Architecture**: Modular system with `LevrFactory_v1` as the entry point, deploying per-project `LevrTreasury_v1`, `LevrGovernor_v1`, `LevrStaking_v1`, and `LevrStakedToken_v1`.

---

### Core Contract Entities

#### LevrFactory_v1

- **Role**: Global configuration owner and deployment/registry entrypoint for projects
- **Responsibilities**:

  - Deploy/clone per-project contracts (`LevrTreasury_v1`, `LevrGovernor_v1`, `LevrStaking_v1`, `LevrStakedToken_v1`)
  - Manage protocol-wide configuration (fees, limits, tiers, deadlines)
  - Register projects with optional treasury reuse

- **Key Storage**:
  - `protocolFeeBps`: Fee in basis points for mint/redeem operations
  - `submissionDeadlineSeconds`: Proposal deadline (default 7 days)
  - `maxSubmissionPerType`: Max proposals per type per 7-day window
  - `stakingBoostTiers`, `transferTiers`: Governance tier configurations
- `minWTokenToSubmit`: Minimum staked token balance to submit proposals
  - `protocolTreasury`: Protocol fee recipient address
  - Contract implementation addresses for cloning

#### LevrTreasury_v1 (Per-Project)

- **Role**: Custody and execution contract for project assets and governance decisions
- **Responsibilities**:

  - Hold underlying reserve tokens and receive Clanker airdrops/fees
  - Execute transfers authorized by governor
  - Apply boosts by moving tokens to staking and accruing rewards

- **Key Storage**:
  - `underlying`: Address of the Clanker token
  - `governor`: Address of the project's governor contract
  - (no wrapper)

#### LevrGovernor_v1 (Per-Project)

- **Role**: Governance and proposal execution for project treasury decisions
- **Responsibilities**:

  - Handle proposal submissions (transfer requests, staking boosts)
  - Enforce submission limits, deadlines, and tier constraints
  - Execute approved proposals on the treasury

- **Key Storage**:
  - Active proposals with metadata (type, amounts, deadlines, tiers)
  - Rolling counters for submission rate limiting
  - Proposal execution state and voting records

#### LevrStaking_v1 (Per-Project)

- **Role**: Escrows underlying stakes and manages multi-token reward accrual and claims
- **Responsibilities**:
  - Stake/unstake underlying; mint/burn `LevrStakedToken_v1` 1:1
  - Accrue rewards per token via `accrueRewards` or `accrueFromTreasury`
  - Claim rewards per token to a recipient

#### LevrStakedToken_v1 (Per-Project)

- **Role**: 1:1 staked token representing staked balances; governance weight source

---

### Contract Interactions and Flow

#### Project Registration

1. **External Call**: `LevrFactory_v1.register(clankerToken, params)`

   - `params.treasury`: Optional existing treasury address
   - Validates clankerToken exists and is properly configured

2. **Contract Deployment**:

   - If `params.treasury` provided: Use existing treasury, validate ownership
   - Otherwise: Deploy new `LevrTreasury_v1` via clone/factory pattern
   - Deploy `LevrGovernor_v1` with treasury as execution target

- Deploy `LevrStaking_v1` and `LevrStakedToken_v1`

3. **Initialization**:

- Treasury: Set governor and underlying addresses
- Governor: Set treasury address and factory config reference
- Staking: Initialize with underlying and staked token; staking controls staked token mint/burn

#### Staking and Boost Flows

**Stake/Unstake**:

```
User → Underlying.transferFrom(user, staking, amount)
Staking → mint sToken 1:1 to user

User → burn sToken
Staking → transfer underlying back to user
```

**Airdrop/Boost**:

```
Clanker → Treasury (fees/airdrops)
Governor → Treasury.applyBoost(amount)
Treasury → Staking.accrueFromTreasury(underlying, amount, pull=true)
Staking → accPerShare[underlying] += amount / totalStaked
```

#### Governance Proposals

**Proposal Creation**:

- Validate `msg.sender` holds ≥ `minWTokenToSubmit` wrapper tokens
- Check rolling submission limits per type (7-day windows)
- Validate amount constraints against selected tier
- Store proposal with deadline (`block.timestamp + submissionDeadlineSeconds`)

**Proposal Execution**:

- Verify proposal deadline not exceeded
- Execute treasury action based on proposal type
- Update rolling counters and emit events

---

### Fee Model and Accounting

#### Fees

- **Protocol Fee**: `protocolFeeBps / 10000` of operation amount on applicable actions (forwarded to protocol treasury)

#### Rounding and Precision

- Use conservative rounding favoring reserves safety
- Track fee accumulations in project treasury for governance distribution
- Emit fee collection events for transparency

#### Invariants

- Wrapper total supply ≤ underlying balance in treasury (accounting for collected fees)
- Protocol fees forwarded correctly to protocol treasury (no project fee path)
- Governance proposals execute atomically with proper access controls

---

### Governance: Submission Limits and Tiers

#### Global Configuration (Factory Level)

- `submissionDeadlineSeconds: uint32` — Common deadline for all proposal types (default: 604,800 = 7 days)
- `maxSubmissionPerType: uint16` — Max proposals per type per rolling 7-day window
- `minWTokenToSubmit: uint256` — Minimum wrapper balance required to submit proposals

#### Tier Definitions

**Transfer Tiers** (absolute amounts in underlying units):

- `low`, `mid`, `high`: Maximum transfer amounts per proposal

**Staking Boost Tiers** (fraction of treasury or emissions):

- `low`, `mid`, `high`: Boost percentages (e.g., 0.03, 0.6, 0.9)

#### Rolling Window Enforcement

- Track submissions per `(projectId, proposalType, weekStart)` mapping
- Use `block.timestamp / 604800` for week calculation
- Revert if `currentCount >= maxSubmissionPerType`

---

### Security Considerations

#### Access Control

- **Factory**: Only owner can update global configuration
- **Treasury**: Only governor can execute transfers and boosts
- **Governor**: Only wrapper holders meeting minimum balance can propose
- **Wrapper**: Treasury has exclusive mint/burn rights

#### Reentrancy Protection

- Non-reentrant guards on all external treasury functions
- Wrap/unwrap operations use checks-effects-interactions pattern
- Fee calculations completed before token transfers

#### Input Validation

- All addresses validated as non-zero
- Amounts checked against tier limits and balance availability
- Deadline calculations prevent overflow/underflow

#### Emergency Controls

- Factory owner can pause registrations if needed
- Treasury includes emergency withdrawal mechanisms (governance-controlled)
- Wrapper includes optional pauser role for extreme circumstances

---

### Contract Interfaces (Implementation Requirements)

#### LevrFactory_v1

```solidity
interface ILevrFactory_v1 {
    function register(
        address clankerToken,
        RegisterParams calldata params
    ) external returns (address governor, address stakedToken);

    function updateConfig(FactoryConfig calldata cfg) external;

    function getProjectContracts(address clankerToken)
        external view returns (address treasury, address governor, address staking, address stakedToken);

    function streamWindowSeconds() external view returns (uint32);
}

struct RegisterParams {
    address treasury; // optional: reuse existing treasury
    bytes extraConfig; // future extension data
}

struct FactoryConfig {
    uint16 protocolFeeBps;
    uint32 submissionDeadlineSeconds;
    uint16 maxSubmissionPerType;
    uint32 streamWindowSeconds;
    TierConfig[] transferTiers;
    TierConfig[] stakingBoostTiers;
    uint256 minWTokenToSubmit;
    address protocolTreasury;
}
```

#### LevrTreasury_v1

```solidity
interface ILevrTreasury_v1 {
    function transfer(address to, uint256 amount) external;
    function applyBoost(uint256 amount) external;
    function getUnderlyingBalance() external view returns (uint256);
    function underlying() external view returns (address);
}
```

#### LevrGovernor_v1

```solidity
interface ILevrGovernor_v1 {
    function proposeTransfer(
        address receiver,
        uint256 amount,
        string calldata reason,
        uint8 tier
    ) external returns (uint256 proposalId);

    function proposeBoost(
        uint256 amount,
        uint8 tier
    ) external returns (uint256 proposalId);

    function execute(uint256 proposalId) external;

    function getProposal(uint256 proposalId)
        external view returns (Proposal memory);

    function canSubmit(address proposer) external view returns (bool);
}

struct Proposal {
    address proposer;
    ProposalType proposalType;
    address receiver;
    uint256 amount;
    string reason;
    uint8 tier;
    uint32 deadline;
    bool executed;
}
```

#### LevrERC20

```solidity
interface ILevrERC20 is IERC20 {
    function mint(address to, uint256 amount) external;
    function burn(address from, uint256 amount) external;

    function decimals() external view returns (uint8);
    function underlying() external view returns (address);
}
```

---

### Implementation Patterns and Best Practices

#### Contract Deployment

- Use minimal proxy (ERC-1167) clones for gas-efficient deployment
- Initialize contracts with immutable references to avoid storage costs
- Validate all constructor parameters and relationships

#### Storage Optimization

- Pack related variables into single slots where possible
- Use mappings for per-user/project data to avoid iteration
- Cache frequently accessed factory config in governor contracts

#### Event Emission

- Emit comprehensive events for all state changes
- Include indexed parameters for efficient off-chain querying
- Follow ERC-20/ERC-721 event standards where applicable

#### Error Handling

- Use custom errors instead of string reverts for gas efficiency
- Provide descriptive error messages for debugging
- Validate inputs at function boundaries

---

### Testing Guidance (Contract-Focused)

#### Unit Tests

- Test all fee calculations and edge cases (rounding, overflow)
- Validate tier enforcement and submission limits
- Test proposal lifecycle (create → execute → cleanup)
- Verify access controls and permission boundaries

#### Integration Tests

- End-to-end wrap/unwrap flows with fee collection
- Governance proposal creation and execution
- Multi-project registration and isolation
- Emergency controls and pause functionality

#### Invariant Tests

- Wrapper supply never exceeds treasury underlying balance
- Fee collections properly accounted and split
- Governance proposals execute atomically
- Rolling counters accurately track submission limits

#### Fuzz Tests

- Random fee configurations and tier selections
- Arbitrary proposal amounts and deadlines
- Concurrent operations and reentrancy attempts
- Edge case amounts (0, max uint256, etc.)

---

### Migration and Deployment Notes

- **From v1**: No automatic migration path; v1 requires fresh deployment
- **Contract Verification**: All contracts should be verified on deployment networks
- **Proxy Patterns**: Consider upgradeable proxies for critical infrastructure contracts
- **Initialization**: Ensure proper initialization order and validation

---

This rule is normative for contract implementations. All contract code should align with the above specifications. Any architectural changes should update this document first.

---
alwaysApply: false
---

# ‚ö†Ô∏è CRITICAL: RULE MAINTENANCE ‚ö†Ô∏è

**THIS RULE MUST BE KEPT UP TO DATE WITH THE CODEBASE**

When making ANY architectural changes, contract modifications, or adding new features:

1. **IMMEDIATELY update this rule** to reflect the changes
2. Update the architecture diagrams
3. Update contract descriptions and functions
4. Update code patterns and examples
5. Add any new design decisions or rationale

**Outdated rules lead to incorrect agent behavior and hallucinated code.**

**Last Major Update**: 2025-10-08 - Added complete governance system with time-weighted voting

---

# Levr Protocol v1 ‚Äî Architecture Guide

**Source-of-truth for Levr Protocol v1 contracts. Modular system: Factory deploys per-project Treasury, Governor, Staking, and StakedToken.**

**‚ú® Full ERC2771 meta-transaction support** - Users can interact gaslessly via trusted forwarder.

**‚ú® Time-weighted governance** - Rewards long-term stakers with higher voting power while ensuring broad participation.

## Architecture

```
LevrFactory_v1 (uses pre-deployed ERC2771Forwarder)
  ‚Üì prepareForDeployment() ‚Üí (treasury, staking)
  ‚Üì register(clankerToken) ‚Üí Project{treasury, governor, staking, stakedToken}
    ‚îú‚îÄ Treasury: Holds project funds, controlled by governor
    ‚îú‚îÄ Governor: Time-weighted governance with cycle-based proposals
    ‚îú‚îÄ Staking: Escrows tokens, tracks time for VP, manages rewards
    ‚îî‚îÄ StakedToken: 1:1 receipt token, governance weight source

All contracts extend ERC2771ContextBase ‚Üí support meta-transactions
```

## Contracts

### LevrFactory_v1 (Singleton)

**Role**: Registry and deployment coordinator

**Extends**: `ERC2771Context` (supports meta-transactions)

**Constructor**: `constructor(FactoryConfig, owner, trustedForwarder)`

- Accepts a pre-deployed `ERC2771Forwarder` address
- Factory itself supports meta-transactions for `prepareForDeployment()` and `register()`
- All contracts deployed by factory trust the same forwarder

**Functions**:

- `prepareForDeployment()` ‚Üí Deploy treasury & staking, return addresses
  - Anyone can call; stores `deployer ‚Üí PreparedContracts`
  - Uses `_msgSender()` for meta-tx support
  - Call BEFORE Clanker deployment to get addresses
  - Passes `trustedForwarder` to deployed contracts
- `register(clankerToken)` ‚Üí Complete setup, return `Project` struct
  - Only `clankerToken.tokenAdmin()` can call
  - Uses `_msgSender()` for meta-tx support
  - Auto-uses prepared contracts from caller (or deploys new)
  - Returns `Project{treasury, governor, staking, stakedToken}`
- `getProjectContracts(clankerToken)` ‚Üí Query registered project
- `trustedForwarder()` ‚Üí Returns the deployed forwarder address
- `executeTransaction(target, data)` ‚Üí Execute arbitrary call from factory
  - Public function, anyone can call
  - Useful for chaining transactions in forwarder multicall
  - Executes call FROM the factory contract
  - Returns `(success, returnData)`

**Security**: Only deployer can use their prepared contracts; only tokenAdmin can register

**Meta-Transactions**: Factory and all deployed contracts support gasless transactions via the forwarder

---

### ERC2771ContextBase (Base Contract)

**Role**: Base contract for meta-transaction support

**Location**: `src/base/ERC2771ContextBase.sol`

**Purpose**:

- Eliminates code duplication across contracts
- Provides centralized ERC2771Context overrides
- Resolves multiple inheritance (ReentrancyGuard + ERC2771Context)

**Usage**: All user-facing contracts extend this base:

```solidity
contract LevrStaking_v1 is ILevrStaking_v1, ReentrancyGuard, ERC2771ContextBase {
  constructor(address trustedForwarder) ERC2771ContextBase(trustedForwarder) {}

  function stake(uint256 amount) external {
    address staker = _msgSender(); // Extracts real sender from meta-tx
    // ...
  }
}
```

**Key Pattern**: Use `_msgSender()` instead of `msg.sender` everywhere to support meta-transactions

---

### LevrTreasury_v1

**Role**: Asset custody (NOT Ownable - governor controls)

**Extends**: `ERC2771ContextBase` (supports meta-transactions)

**Constructor**: `constructor(address factory_, address trustedForwarder)`

**Functions**:

- `transfer(to, amount)` ‚Üí Governor-authorized transfer
- `applyBoost(amount)` ‚Üí Move to staking, accrue rewards
- `initialize(governor, underlying)` ‚Üí One-time init by factory

**Access**: `onlyGovernor` modifier (uses `_msgSender()` for meta-tx support)

**Meta-Transaction Support**: Governor calls can be relayed via forwarder

---

### LevrGovernor_v1

**Role**: Time-weighted governance with cycle-based proposal management

**Extends**: `ERC2771ContextBase` (supports meta-transactions)

**Constructor**: `constructor(address factory_, address treasury_, address staking_, address stakedToken_, address underlying_, address trustedForwarder)`

**Governance Model**:

- **Voting Power**: VP = staked balance √ó time staked (resets on unstake)
- **Proposal Types**: BoostStakingPool (treasury ‚Üí staking), TransferToAddress (treasury ‚Üí recipient)
- **Cycle Management**: Manual start via `startNewCycle()` (factory owner only)
- **Quorum**: Balance-based participation (% of token supply that voted)
- **Approval**: VP-weighted voting (rewards long-term stakers)
- **Winner Selection**: One proposal executes per cycle (highest VP yes votes)

**Functions**:

- `startNewCycle()` ‚Üí Starts new governance cycle (factory owner only)
- `proposeBoost(amount)` ‚Üí Boost staking rewards (gasless via meta-tx)
- `proposeTransfer(recipient, amount, description)` ‚Üí Transfer to address (gasless via meta-tx)
- `vote(proposalId, support)` ‚Üí Vote yes/no with time-weighted VP (gasless via meta-tx)
- `execute(proposalId)` ‚Üí Execute winning proposal (anyone can call)
- `getProposal(proposalId)` ‚Üí View proposal details
- `getVotingPowerSnapshot(proposalId, user)` ‚Üí Get user's VP for proposal
- `state(proposalId)` ‚Üí Pending/Active/Defeated/Succeeded/Executed
- `getWinner(cycleId)` ‚Üí Get winning proposal for cycle
- `meetsQuorum(proposalId)` ‚Üí Check quorum (balance participation)
- `meetsApproval(proposalId)` ‚Üí Check approval (VP voting)

**Validation**:

- Min staked balance (minSTokenBpsToSubmit % of supply)
- Proposal window timing
- Voting window timing
- Max concurrent proposals per type
- Quorum threshold (quorumBps)
- Approval threshold (approvalBps)

**Meta-Transaction Support**: Users can propose and vote without holding ETH

---

### LevrStaking_v1

**Role**: Stake escrow, multi-token rewards with manual accrual, governance time tracking

**Extends**: `ERC2771ContextBase` (supports meta-transactions)

**Constructor**: `constructor(address trustedForwarder)`

**Functions**:

- `stake(amount)`, `unstake(amount, to)` ‚Üí Mint/burn stakedToken 1:1 (gasless via meta-tx)
- `accrueRewards(token)` ‚Üí **Manual reward accrual** (requires explicit call)
- `accrueFromTreasury(token, amount, pull)` ‚Üí Boost from treasury
- `claimRewards(tokens[], to)` ‚Üí Multi-token claim (gasless via meta-tx)
- `outstandingRewards(token)` ‚Üí Check available and pending rewards from ClankerFeeLocker
- `initialize(underlying, stakedToken, treasury, factory)` ‚Üí One-time init by factory

**Governance Functions**:

- `stakeStartTime(user)` ‚Üí Public getter for when user started staking
- `getVotingPower(user)` ‚Üí Returns VP = balance √ó (block.timestamp - stakeStartTime)

**Time Tracking Logic**:

- **First stake** (balance was 0): Sets `stakeStartTime = block.timestamp`
- **Top-up**: Preserves existing stakeStartTime (doesn't reset)
- **Claim rewards**: Preserves stakeStartTime (doesn't reset)
- **Unstake** (any amount): Resets `stakeStartTime = 0`

**üîÑ UPDATED Reward Paths** (Manual Accrual System):

1. **Manual Accrual**: Transfer tokens to staking contract, then call `accrueRewards(token, amount)`
2. **Treasury Boost**: `governor.proposeBoost()` ‚Üí `treasury.applyBoost()` ‚Üí `staking.accrueFromTreasury()`
3. **ClankerFeeLocker Integration**: Automatically claims pending fees before manual accrual

**‚ö†Ô∏è BREAKING CHANGE**: Removed ERC1363 auto-accrual functionality

- No longer implements `IERC1363Receiver`
- No automatic reward crediting on `transferAndCall()`
- All reward accrual requires explicit function calls

**ClankerFeeLocker Integration**:

- `_claimFromClankerFeeLocker()` ‚Üí Automatically claims pending rewards before accrual
- `_getPendingFromClankerFeeLocker()` ‚Üí Check pending rewards in ClankerFeeLocker
- `getClankerFeeLocker()` ‚Üí Get the associated ClankerFeeLocker address

**Safety**: Reserve tracking, liquidity checks, streaming windows (3-day default)

**Meta-Transaction Support**: Users can stake/unstake/claim without holding ETH

---

### LevrStakedToken_v1

**Role**: 1:1 staked representation, governance weight

**Access**: Only staking can mint/burn

## Deployment Flow

### Complete Workflow

```solidity
// 1. Deploy forwarder FIRST
LevrForwarder_v1 forwarder = new LevrForwarder_v1("LevrForwarder_v1");

// 2. Deploy factory with forwarder
LevrFactory_v1 factory = new LevrFactory_v1(config, owner, address(forwarder));

// 3. Prepare (get addresses before Clanker exists)
(address treasury, address staking) = factory.prepareForDeployment();

// 4. Deploy Clanker token
// - Set treasury as airdrop recipient ‚Üí receives initial allocation
// - Set staking as LP fee recipient ‚Üí receives ongoing trading fees

// 5. Register (as tokenAdmin)
ILevrFactory_v1.Project memory project = factory.register(clankerToken);
// Access: project.treasury, project.governor, project.staking, project.stakedToken
```

### Initialization Sequence

1. Forwarder deployed independently
2. Factory deployed with forwarder address
3. Treasury & Staking deployed via `prepareForDeployment()`
4. Clanker token deployed (uses treasury/staking addresses)
5. `register()` deploys governor & stakedToken, initializes all contracts
6. Governor set as treasury controller, staking linked to treasury

---

## Core Flows

### Staking

```
User stakes ‚Üí Staking escrows underlying, mints stakedToken 1:1
User unstakes ‚Üí Staking burns stakedToken, returns underlying
```

### Rewards (Manual Accrual System)

```
Clanker LP fees ‚Üí ClankerFeeLocker ‚Üí Manual accrual via accrueRewards()
Clanker airdrops ‚Üí Treasury
Manual rewards ‚Üí Transfer to staking ‚Üí accrueRewards(token, amount)
Governor proposes boost ‚Üí Treasury.applyBoost(amount)
Treasury ‚Üí Staking.accrueFromTreasury (measures delta, credits immediately)
Users claim ‚Üí Multi-token claim with reserve checks
```

### Governance (Time-Weighted Voting)

```
1. Factory owner starts cycle ‚Üí governor.startNewCycle()
   ‚îú‚îÄ Proposal window: proposalWindowSeconds (e.g., 2 days)
   ‚îî‚îÄ Voting window: votingWindowSeconds (e.g., 5 days)

2. Users stake ‚Üí Accumulate time-weighted VP
   VP = staked balance √ó time staked (seconds)

3. Proposal window (users with ‚â• minSTokenBpsToSubmit can propose)
   ‚îú‚îÄ proposeBoost(amount) ‚Üí Treasury ‚Üí Staking reward pool
   ‚îî‚îÄ proposeTransfer(recipient, amount, description) ‚Üí Treasury ‚Üí Recipient

4. Voting window (all stakers can vote)
   ‚îú‚îÄ vote(proposalId, support=true/false)
   ‚îú‚îÄ VP calculated at proposal.createdAt (blocks last-minute staking)
   ‚îî‚îÄ Tracks totalBalanceVoted for quorum

5. Execution (after voting ends)
   ‚îú‚îÄ Check quorum: totalBalanceVoted ‚â• (quorumBps / 10000) √ó totalSupply
   ‚îú‚îÄ Check approval: yesVotes ‚â• (approvalBps / 10000) √ó (yesVotes + noVotes)
   ‚îú‚îÄ Select winner: Highest VP yes votes among eligible proposals
   ‚îî‚îÄ Execute: Only ONE proposal per cycle

6. Treasury performs action
   ‚îú‚îÄ BoostStakingPool: treasury.applyBoost(amount) ‚Üí staking
   ‚îî‚îÄ TransferToAddress: treasury.transfer(recipient, amount)
```

**Anti-Gaming**: VP snapshot at proposal creation, unstake resets timer, per-type concurrency limits

### Governance Deep Dive

**Quorum vs Approval (Dual Threshold System)**:

- **Quorum**: Measures participation using **balance** (not VP)
  - Formula: `totalBalanceVoted ‚â• (quorumBps / 10000) √ó totalSupply`
  - Purpose: Ensures broad community engagement
  - Example: 70% quorum = at least 70% of token supply must vote
- **Approval**: Measures preference using **VP** (time-weighted)
  - Formula: `yesVotes ‚â• (approvalBps / 10000) √ó (yesVotes + noVotes)`
  - Purpose: Rewards long-term commitment
  - Example: 51% approval = yes votes must be ‚â• 51% of total VP cast

**Why Two Different Metrics?**

- Prevents minority with high VP from passing proposals alone (quorum ensures broad participation)
- Rewards long-term stakers with more influence on what passes (approval uses VP weighting)

**VP Calculation** (On-Demand):

- Calculated when user votes: `balance √ó (proposal.createdAt - stakeStartTime)`
- Returns 0 if user staked after proposal was created
- Cached in `vpSnapshot` mapping for later queries
- No gas-intensive enumeration at proposal creation

**Cycle State Management**:

```solidity
struct Cycle {
  uint256 proposalWindowStart;
  uint256 proposalWindowEnd;  // proposalWindowStart + proposalWindowSeconds
  uint256 votingWindowEnd;    // proposalWindowEnd + votingWindowSeconds
  bool executed;              // Prevents multiple executions
}
```

## Data Structures

```solidity
struct Project {
  address treasury;
  address governor;
  address staking;
  address stakedToken;
}

struct PreparedContracts {
  address treasury;
  address staking;
}
```

---

## Security

### Access Controls

| Function                           | Who Can Call                                   |
| ---------------------------------- | ---------------------------------------------- |
| `factory.prepareForDeployment()`   | Anyone (tracked by deployer)                   |
| `factory.register()`               | Only `clankerToken.tokenAdmin()`               |
| `factory.updateConfig()`           | Only factory owner                             |
| `treasury.transfer/applyBoost()`   | Only governor                                  |
| `governor.startNewCycle()`         | Only factory owner (TODO: improve)             |
| `governor.proposeBoost/Transfer()` | Anyone with `minSTokenBpsToSubmit` % of supply |
| `governor.vote()`                  | Anyone (uses VP from snapshot)                 |
| `governor.execute()`               | Anyone (if proposal is winner)                 |
| `staking.stake/unstake/claim()`    | Anyone                                         |
| `staking.accrueRewards()`          | Anyone (manual accrual)                        |
| `staking.accrueFromTreasury()`     | Only treasury (during applyBoost)              |
| `stakedToken.mint/burn()`          | Only staking                                   |

### Protections

- **Reentrancy**: Guards on all treasury/staking external functions
- **Double Registration**: Prevented via `ALREADY_REGISTERED` check
- **Front-running**: Only deployer can use their prepared contracts
- **Reward Safety**: Reserve tracking prevents overdraw
- **No Owner on Treasury**: Governor controls all operations
- **Manual Accrual**: Explicit reward crediting prevents unexpected behavior

### Invariants

- StakedToken supply == total underlying staked
- Reward reserves >= pending claims
- One project per clankerToken
- Prepared contracts only usable by deployer

## Configuration

### Factory Config

```solidity
struct FactoryConfig {
  uint16 protocolFeeBps;           // Protocol fee (basis points)
  uint32 streamWindowSeconds;      // Reward streaming window (‚â• 1 day required)
  address protocolTreasury;        // Protocol treasury address
  // Governance parameters
  uint32 proposalWindowSeconds;    // Duration of proposal submission window
  uint32 votingWindowSeconds;      // Duration of voting window after proposals close
  uint16 maxActiveProposals;       // Max concurrent proposals per type (e.g., 7)
  uint16 quorumBps;                // Min participation threshold (e.g., 7000 = 70%)
  uint16 approvalBps;              // Min approval threshold (e.g., 5100 = 51%)
  uint16 minSTokenBpsToSubmit;     // Min % of sToken supply to propose (e.g., 100 = 1%)
}
```

**Validation**:

- `streamWindowSeconds` must be ‚â• 1 day (enforced in `_applyConfig`)
- All parameters configurable via `updateConfig()` (owner only)

**Defaults (Recommended)**:

- `proposalWindowSeconds`: 2 days (48 hours)
- `votingWindowSeconds`: 5 days
- `maxActiveProposals`: 7 per type
- `quorumBps`: 7000 (70%)
- `approvalBps`: 5100 (51%)
- `minSTokenBpsToSubmit`: 100 (1%)
- `streamWindowSeconds`: 3 days

**Note**: `trustedForwarder` is NOT in config - must be deployed before factory

### Proposal System

**Governance Cycles**: Manual start via `governor.startNewCycle()`

- Proposal window: Users can create proposals
- Voting window: Users vote with time-weighted VP
- Execution: Only the winning proposal executes

**Proposal Amounts**: No tiers - proposers specify exact amounts for transfers and boosts

**Per-Type Limits**: BoostStakingPool and TransferToAddress have separate `maxActiveProposals` counts

### Meta-Transaction Forwarder

- **Implementation**: `LevrForwarder_v1` (extends OpenZeppelin's `ERC2771Forwarder`)
- **Deployment**: Must be deployed BEFORE factory
- **Name**: "LevrForwarder_v1"
- **Features**:
  - Standard ERC2771 meta-transaction support (via `execute()`)
  - **Multicall support** (via `executeMulticall()`) - execute multiple calls in ONE transaction
  - Signature verification and nonce management
- **Access**: `factory.trustedForwarder()` returns address
- **Immutable**: Cannot be changed after factory deployment
- **Shared**: All projects from same factory use same forwarder
- **Factory Support**: Factory itself supports meta-tx for `prepareForDeployment()` and `register()`

---

## Code Patterns

### Manual Reward Accrual

```solidity
// NEW: Manual accrual pattern
MockERC20 rewardToken = new MockERC20("Reward", "RWD");
rewardToken.mint(address(this), 1000 ether);

// Transfer tokens to staking
rewardToken.transfer(address(staking), 1000 ether);

// Manually accrue rewards (REQUIRED step)
staking.accrueRewards(address(rewardToken), 1000 ether);

// Now users can claim the rewards
address[] memory tokens = new address[](1);
tokens[0] = address(rewardToken);
staking.claimRewards(tokens, address(this));
```

### Registration

```solidity
// Deploy forwarder FIRST
LevrForwarder_v1 forwarder = new LevrForwarder_v1("LevrForwarder_v1");

// Factory setup with forwarder
LevrFactory_v1 factory = new LevrFactory_v1(config, owner, address(forwarder));

// Prepare before Clanker
(address treas, address stak) = factory.prepareForDeployment();

// Deploy Clanker (use treas & stak addresses)

// Register
ILevrFactory_v1.Project memory p = factory.register(clankerToken);
```

### Accessing Components

```solidity
ILevrFactory_v1.Project memory proj = factory.getProjectContracts(token);

LevrTreasury_v1(payable(proj.treasury));
LevrGovernor_v1(proj.governor);
LevrStaking_v1(proj.staking);
LevrStakedToken_v1(proj.stakedToken);
```

### Using Meta-Transactions

```solidity
// Users sign transactions, relayers execute
LevrForwarder_v1 forwarder = LevrForwarder_v1(factory.trustedForwarder());

// Example: Gasless stake
ERC2771Forwarder.ForwardRequestData memory request = ERC2771Forwarder.ForwardRequestData({
  from: user,
  to: address(staking),
  value: 0,
  gas: 300000,
  deadline: uint48(block.timestamp + 1 hours),
  data: abi.encodeWithSelector(LevrStaking_v1.stake.selector, amount),
  signature: userSignature
});

// Relayer executes (pays gas)
forwarder.execute(request);
```

### Chaining Transactions with Multicall

`LevrForwarder_v1.executeMulticall()` enables complex multi-step operations in ONE transaction:

```solidity
// Example: Complete project deployment - prepare + register in ONE transaction!
ILevrForwarder_v1.SingleCall[] memory calls = new ILevrForwarder_v1.SingleCall[](2);

// Call 1: Prepare deployment
calls[0] = ILevrForwarder_v1.SingleCall({
  target: address(factory),
  allowFailure: false,
  callData: abi.encodeWithSelector(LevrFactory_v1.prepareForDeployment.selector)
});

// Call 2: Register token
calls[1] = ILevrForwarder_v1.SingleCall({
  target: address(factory),
  allowFailure: false,
  callData: abi.encodeWithSelector(LevrFactory_v1.register.selector, clankerToken)
});

// Execute as user (multicall extracts user from msg.sender and appends to each call)
forwarder.executeMulticall(calls);
```

**Key Benefit**: User deploys entire project without paying gas - just signs off-chain!

### Creating New Contracts

**ALWAYS extend ERC2771ContextBase for user-facing contracts:**

```solidity
import {ERC2771ContextBase} from './base/ERC2771ContextBase.sol';

contract MyContract is ERC2771ContextBase {
  constructor(address trustedForwarder) ERC2771ContextBase(trustedForwarder) {}

  function myFunction() external {
    address realSender = _msgSender(); // NOT msg.sender!
    // ...
  }
}
```

**NEVER use `msg.sender` directly - always use `_msgSender()`**

---

## Testing

**Must Cover**:

- Security: Access controls, deployer tracking, meta-tx signature verification
- Flows: Stake ‚Üí Manual Accrue ‚Üí Claim ‚Üí Unstake (both direct and meta-tx)
- Governance: Proposals, custom amounts, execution, deadlines (gasless proposals)
- Rewards: Multi-token, reserves, streaming, manual accrual
- Meta-Transactions: Stake, unstake, claim, propose via forwarder
- ClankerFeeLocker: Automatic claiming integration
- Edge cases: Zero amounts, double registration, unauthorized calls
- Forwarder: `isTrustedForwarder()`, signature verification, nonce management

**Test Files**:

- `test/e2e/LevrV1.Governance.t.sol` - **Comprehensive governance E2E tests** (9 tests, all passing)
  - Full governance cycle with time-weighted voting
  - Anti-gaming protections (VP snapshots, timer resets)
  - Concurrency limits, quorum, approval thresholds
  - Winner selection and execution
- `test/e2e/LevrV1.Staking.t.sol` - Staking with real Clanker integration (5 tests)
- `test/e2e/LevrV1.Registration.t.sol` - Registration flow tests (4 tests)
- `test/unit/LevrStakingV1.t.sol` - Staking unit tests (8 tests)
  - Pass `address(0)` for forwarder in unit tests if not testing meta-tx
  - `test_manual_reward_accrual_and_streaming` - Manual accrual flow testing
- `test/unit/LevrGovernorV1.t.sol` - Governor unit tests (1 test)
- `test/unit/LevrTreasuryV1.t.sol` - Treasury unit tests (2 tests)
- `test/unit/LevrStakedTokenV1.t.sol` - StakedToken unit tests (2 tests)
- `test/unit/LevrFactoryV1.*.t.sol` - Factory security and deployment tests (4 tests)

**Test Coverage for Manual Accrual**:

- Test reward transfer + manual accrual
- Test ClankerFeeLocker automatic claiming
- Test insufficient balance scenarios
- Test streaming after manual accrual

## Key Design Decisions

### Why Manual Reward Accrual?

- **Security**: Explicit control over reward crediting prevents unexpected behavior
- **Predictability**: No surprise reward accruals from arbitrary token transfers
- **Integration**: Better integration with ClankerFeeLocker automatic claiming
- **Simplicity**: Removes complex ERC1363 receiver logic

### Why No CREATE2 / Deterministic Addresses?

- **prepareForDeployment**: Simple `new Contract()` - no salting
- **register**: Deploys governor/stakedToken without salts
- **Reason**: Addresses don't need prediction - treasury/staking exist before Clanker

### Why No Ownable on Treasury?

- **Governor controls all operations** via `onlyGovernor` modifier
- **Register is gated** by `tokenAdmin` check - no front-running
- **Simpler, cleaner** - one less security layer to manage

### Why Auto-Lookup of Prepared Contracts?

- **Mapping tracks deployer** ‚Üí `PreparedContracts{treasury, staking}`
- **register() auto-uses** prepared contracts from `msg.sender`
- **Security**: Only deployer can use their contracts (no parameters to hijack)

### Why Return Project Struct?

- **Cleaner API**: One struct vs four separate addresses
- **Type safety**: All addresses grouped logically
- **Easier usage**: `proj.treasury` vs destructuring

### Why Forwarder Deployed Before Factory?

- **Factory Meta-TX Support**: Factory needs to extend ERC2771Context to support meta-tx on `prepareForDeployment()` and `register()`
- **Constructor Limitation**: Can't deploy forwarder in constructor if factory extends ERC2771Context
- **Security**: Immutable, can't be changed after deployment
- **Consistency**: All projects from same factory share same forwarder
- **Standard**: Uses OpenZeppelin's battle-tested `ERC2771Forwarder`
- **Factory Functions**: `prepareForDeployment()` and `register()` use `_msgSender()` for meta-tx support

### Why ERC2771ContextBase Base Contract?

- **DRY Principle**: Eliminates ~135 lines of duplicated override code
- **Maintainability**: One place to update ERC2771 logic
- **Multiple Inheritance**: Cleanly resolves ReentrancyGuard + ERC2771Context diamond pattern
- **Type Safety**: Enforces consistent meta-transaction handling

**Note**: Factory extends `ERC2771Context` directly and implements its own overrides because Solidity's override specification doesn't allow inheriting through abstract base contracts in complex diamond patterns.

### Why executeTransaction on Factory?

- **Multicall Composition**: Enables complex transaction chains via forwarder
- **Flexible Routing**: Factory can execute arbitrary calls in multicall sequences
- **Gas Efficiency**: Single meta-tx signature covers multiple operations
- **Public Access**: No restrictions - useful for composability
- **Reentrancy Protected**: Uses ReentrancyGuard for safety

---

## Changes from Previous Versions

### Removed

- ‚ùå **ERC1363 auto-accrual** - No automatic reward crediting on token transfers
- ‚ùå `IERC1363Receiver` implementation - Staking no longer implements this interface
- ‚ùå `onTransferReceived()` functionality - Manual accrual required
- ‚ùå `transferAndCall()` support - Use regular transfers + manual accrual
- ‚ùå `MockERC1363` test utilities - Replaced with standard ERC20 testing
- ‚ùå `registerDryRun()` - unreliable prediction
- ‚ùå CREATE2 salting - not needed
- ‚ùå Treasury `Ownable` - redundant
- ‚ùå Multiple return values - now returns struct
- ‚ùå Treasury/staking params in register - auto-lookup
- ‚ùå Tier system - replaced with custom amounts
- ‚ùå **Deprecated FactoryConfig fields**:
  - `submissionDeadlineSeconds` - Removed (governance uses voting window instead)
  - `maxSubmissionPerType` - Replaced by `maxActiveProposals` (per-type concurrency)
  - `minWTokenToSubmit` - Replaced by `minSTokenBpsToSubmit` (percentage-based)
- ‚ùå Wrapper token system - Never implemented in v1
- ‚ùå `test/e2e/LevrV1.Treasury.t.sol` - Redundant (covered by treasury unit + governance E2E)

### Added

- ‚úÖ **Time-weighted governance system** (LevrGovernor_v1)
  - Voting power = staked balance √ó time staked
  - VP snapshot at proposal creation (prevents last-minute gaming)
  - Dual threshold: quorum (balance participation) + approval (VP voting)
  - Cycle-based proposal management
  - Per-type concurrency limits
  - Winner selection (highest VP yes votes)
- ‚úÖ **Governance parameters in FactoryConfig** (6 new params)
  - proposalWindowSeconds, votingWindowSeconds
  - maxActiveProposals, quorumBps, approvalBps, minSTokenBpsToSubmit
- ‚úÖ **Staking time tracking** for governance
  - stakeStartTime mapping
  - getVotingPower() function
  - Timer resets on unstake (anti-gaming)
- ‚úÖ **Manual reward accrual system** - Explicit `accrueRewards()` calls required
- ‚úÖ **ClankerFeeLocker integration** - Automatic claiming before manual accrual
- ‚úÖ `outstandingRewards()` - Check available and pending rewards
- ‚úÖ `_claimFromClankerFeeLocker()` - Internal automatic claiming
- ‚úÖ `_getPendingFromClankerFeeLocker()` - Check pending fees
- ‚úÖ `prepareForDeployment()` - pre-deploy infrastructure
- ‚úÖ Deployer tracking - security via mapping
- ‚úÖ `Project` struct returns - cleaner API
- ‚úÖ Auto-lookup prepared contracts
- ‚úÖ Treasury receives airdrops, Staking receives fees (split roles)
- ‚úÖ Custom proposal amounts - no tier restrictions
- ‚úÖ **ERC2771 meta-transaction support** - gasless transactions via forwarder
- ‚úÖ **ERC2771ContextBase** - base contract eliminates duplication
- ‚úÖ **executeTransaction** - factory function for multicall composition
- ‚úÖ **streamWindowSeconds validation** - Must be ‚â• 1 day

---

## Critical Patterns and Anti-Patterns

### ‚úÖ DO

- **ALWAYS** use manual reward accrual: transfer tokens + `accrueRewards()`
- **ALWAYS** use `_msgSender()` instead of `msg.sender` in user-facing contracts
- **ALWAYS** extend `ERC2771ContextBase` for new contracts that need meta-tx support (except factory)
- **ALWAYS** deploy forwarder BEFORE factory
- **ALWAYS** pass `trustedForwarder` to contract constructors
- **ALWAYS** update this documentation when making architectural changes
- **CONSIDER** using `factory.executeTransaction()` for complex multicall sequences

### ‚ùå DON'T

- **NEVER** expect automatic reward accrual on token transfers
- **NEVER** use `transferAndCall()` - use transfer + `accrueRewards()`
- **NEVER** implement `IERC1363Receiver` - manual accrual only
- **NEVER** use `msg.sender` directly in contracts that extend ERC2771ContextBase or ERC2771Context
- **NEVER** create custom forwarders - use OpenZeppelin's `ERC2771Forwarder`
- **NEVER** manually override `_msgSender()/_msgData()/_contextSuffixLength()` - use base contract (except factory)
- **NEVER** forget to pass `address(0)` for forwarder in unit tests if not testing meta-tx
- **NEVER** let this documentation become outdated
- **NEVER** deploy factory before deploying forwarder
- **AVOID** using `executeTransaction` for operations requiring specific caller identity

---

## File Structure

```
src/
  base/
    ERC2771ContextBase.sol         # Base contract for meta-tx support
  LevrFactory_v1.sol                # Factory (extends ERC2771Context directly)
  LevrTreasury_v1.sol               # Extends ERC2771ContextBase
  LevrGovernor_v1.sol               # Extends ERC2771ContextBase
  LevrStaking_v1.sol                # Extends ERC2771ContextBase (NO ERC1363)
  LevrStakedToken_v1.sol            # No meta-tx (not user-facing)
  LevrForwarder_v1.sol              # Meta-transaction forwarder
  interfaces/
    ILevrFactory_v1.sol             # Factory interface
    ILevrGovernor_v1.sol            # Governor interface
    ILevrStaking_v1.sol             # Staking interface
    ILevrTreasury_v1.sol            # Treasury interface
    ILevrStakedToken_v1.sol         # StakedToken interface
    ILevrForwarder_v1.sol           # Forwarder interface
    external/
      IClankerFeeLocker.sol         # ClankerFeeLocker interface

test/
  e2e/
    LevrV1.Governance.t.sol         # 9 governance E2E tests (all passing)
    LevrV1.Staking.t.sol            # 5 staking E2E tests with Clanker integration
    LevrV1.Registration.t.sol       # 4 registration flow tests
  unit/
    LevrFactoryV1.PrepareForDeployment.t.sol  # 2 tests
    LevrFactoryV1.Security.t.sol              # 2 tests
    LevrGovernorV1.t.sol            # 1 governor unit test
    LevrStakingV1.t.sol             # 8 staking unit tests (manual accrual)
    LevrTreasuryV1.t.sol            # 2 treasury unit tests
    LevrStakedTokenV1.t.sol         # 2 staked token unit tests
  utils/
    BaseForkTest.sol                # Base test with fork management
    ClankerDeployer.sol             # Clanker token deployment helper
    MerkleAirdropHelper.sol         # Merkle tree helper for airdrop tests
    SwapV4Helper.sol                # Uniswap V4 swap helper
  mocks/
    MockERC20.sol                   # Standard ERC20 mock (ERC1363 removed)
  DeployLevrFactoryDevnet.t.sol    # Deployment script test
```

---

**This rule is normative. All contract code must align with these specifications.**

**‚ö†Ô∏è REMEMBER: Update this rule immediately when making any changes! ‚ö†Ô∏è**

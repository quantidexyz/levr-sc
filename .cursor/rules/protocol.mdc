---
alwaysApply: false
---

# ‚ö†Ô∏è CRITICAL: RULE MAINTENANCE ‚ö†Ô∏è

**THIS RULE MUST BE KEPT UP TO DATE WITH THE CODEBASE**

When making ANY architectural changes, contract modifications, or adding new features:

1. **IMMEDIATELY update this rule** to reflect the changes
2. Update the architecture diagrams
3. Update contract descriptions and functions
4. Update code patterns and examples
5. Add any new design decisions or rationale

**Outdated rules lead to incorrect agent behavior and hallucinated code.**

---

# Levr Protocol v1 ‚Äî Architecture Guide

**Source-of-truth for Levr Protocol v1 contracts. Modular system: Factory deploys per-project Treasury, Governor, Staking, and StakedToken.**

**‚ú® Full ERC2771 meta-transaction support** - Users can interact gaslessly via trusted forwarder.

## Architecture

```
LevrFactory_v1 (deploys ERC2771Forwarder in constructor)
  ‚Üì prepareForDeployment() ‚Üí (treasury, staking)
  ‚Üì register(clankerToken) ‚Üí Project{treasury, governor, staking, stakedToken}

All contracts extend ERC2771ContextBase ‚Üí support meta-transactions
```

## Contracts

### LevrFactory_v1 (Singleton)

**Role**: Registry and deployment coordinator

**Extends**: `ERC2771Context` (supports meta-transactions)

**Constructor**: `constructor(FactoryConfig, owner, trustedForwarder)`

- Accepts a pre-deployed `ERC2771Forwarder` address
- Factory itself supports meta-transactions for `prepareForDeployment()` and `register()`
- All contracts deployed by factory trust the same forwarder

**Functions**:

- `prepareForDeployment()` ‚Üí Deploy treasury & staking, return addresses
  - Anyone can call; stores `deployer ‚Üí PreparedContracts`
  - Uses `_msgSender()` for meta-tx support
  - Call BEFORE Clanker deployment to get addresses
  - Passes `trustedForwarder` to deployed contracts
- `register(clankerToken)` ‚Üí Complete setup, return `Project` struct
  - Only `clankerToken.tokenAdmin()` can call
  - Uses `_msgSender()` for meta-tx support
  - Auto-uses prepared contracts from caller (or deploys new)
  - Returns `Project{treasury, governor, staking, stakedToken}`
- `getProjectContracts(clankerToken)` ‚Üí Query registered project
- `trustedForwarder()` ‚Üí Returns the deployed forwarder address
- `executeTransaction(target, data)` ‚Üí Execute arbitrary call from factory
  - Public function, anyone can call
  - Useful for chaining transactions in forwarder multicall
  - Executes call FROM the factory contract
  - Returns `(success, returnData)`

**Security**: Only deployer can use their prepared contracts; only tokenAdmin can register

**Meta-Transactions**: Factory and all deployed contracts support gasless transactions via the forwarder

---

### ERC2771ContextBase (Base Contract)

**Role**: Base contract for meta-transaction support

**Location**: `src/base/ERC2771ContextBase.sol`

**Purpose**:

- Eliminates code duplication across contracts
- Provides centralized ERC2771Context overrides
- Resolves multiple inheritance (ReentrancyGuard + ERC2771Context)

**Usage**: All user-facing contracts extend this base:

```solidity
contract LevrStaking_v1 is ILevrStaking_v1, ReentrancyGuard, ERC2771ContextBase {
  constructor(address trustedForwarder) ERC2771ContextBase(trustedForwarder) {}

  function stake(uint256 amount) external {
    address staker = _msgSender(); // Extracts real sender from meta-tx
    // ...
  }
}
```

**Key Pattern**: Use `_msgSender()` instead of `msg.sender` everywhere to support meta-transactions

---

### LevrTreasury_v1

**Role**: Asset custody (NOT Ownable - governor controls)

**Extends**: `ERC2771ContextBase` (supports meta-transactions)

**Constructor**: `constructor(address factory_, address trustedForwarder)`

**Functions**:

- `transfer(to, amount)` ‚Üí Governor-authorized transfer
- `applyBoost(amount)` ‚Üí Move to staking, accrue rewards
- `initialize(governor, underlying)` ‚Üí One-time init by factory

**Access**: `onlyGovernor` modifier (uses `_msgSender()` for meta-tx support)

**Meta-Transaction Support**: Governor calls can be relayed via forwarder

---

### LevrGovernor_v1

**Role**: Governance and proposals

**Extends**: `ERC2771ContextBase` (supports meta-transactions)

**Constructor**: `constructor(address factory_, address treasury_, address stakedToken_, address trustedForwarder)`

**Functions**:

- `proposeTransfer(receiver, amount, reason)` ‚Üí Custom amounts (gasless via meta-tx)
- `proposeBoost(amount)` ‚Üí Custom amounts (gasless via meta-tx)
- `execute(proposalId)` ‚Üí Anyone can execute
- `getProposal(proposalId)` ‚Üí View proposal
- `canSubmit(proposer)` ‚Üí Check eligibility

**Validation**: Min staked balance, rolling windows, deadlines

**Meta-Transaction Support**: Users can submit proposals without holding ETH

---

### LevrStaking_v1

**Role**: Stake escrow, multi-token rewards with manual accrual

**Extends**: `ERC2771ContextBase` (supports meta-transactions)

**Constructor**: `constructor(address trustedForwarder)`

**Functions**:

- `stake(amount)`, `unstake(amount, to)` ‚Üí Mint/burn stakedToken 1:1 (gasless via meta-tx)
- `accrueRewards(token, amount)` ‚Üí **Manual reward accrual** (NEW: requires explicit call)
- `accrueFromTreasury(token, amount, pull)` ‚Üí Boost from treasury
- `claimRewards(tokens[], to)` ‚Üí Multi-token claim (gasless via meta-tx)
- `outstandingRewards(token)` ‚Üí Check available and pending rewards from ClankerFeeLocker
- `initialize(underlying, stakedToken, treasury)` ‚Üí One-time init by factory

**üîÑ UPDATED Reward Paths** (Manual Accrual System):

1. **Manual Accrual**: Transfer tokens to staking contract, then call `accrueRewards(token, amount)`
2. **Treasury Boost**: `governor.proposeBoost()` ‚Üí `treasury.applyBoost()` ‚Üí `staking.accrueFromTreasury()`
3. **ClankerFeeLocker Integration**: Automatically claims pending fees before manual accrual

**‚ö†Ô∏è BREAKING CHANGE**: Removed ERC1363 auto-accrual functionality

- No longer implements `IERC1363Receiver`
- No automatic reward crediting on `transferAndCall()`
- All reward accrual requires explicit function calls

**ClankerFeeLocker Integration**:

- `_claimFromClankerFeeLocker()` ‚Üí Automatically claims pending rewards before accrual
- `_getPendingFromClankerFeeLocker()` ‚Üí Check pending rewards in ClankerFeeLocker
- `getClankerFeeLocker()` ‚Üí Get the associated ClankerFeeLocker address

**Safety**: Reserve tracking, liquidity checks, streaming windows (3-day default)

**Meta-Transaction Support**: Users can stake/unstake/claim without holding ETH

---

### LevrStakedToken_v1

**Role**: 1:1 staked representation, governance weight

**Access**: Only staking can mint/burn

## Deployment Flow

### Complete Workflow

```solidity
// 1. Deploy forwarder FIRST
LevrForwarder_v1 forwarder = new LevrForwarder_v1("LevrForwarder_v1");

// 2. Deploy factory with forwarder
LevrFactory_v1 factory = new LevrFactory_v1(config, owner, address(forwarder));

// 3. Prepare (get addresses before Clanker exists)
(address treasury, address staking) = factory.prepareForDeployment();

// 4. Deploy Clanker token
// - Set treasury as airdrop recipient ‚Üí receives initial allocation
// - Set staking as LP fee recipient ‚Üí receives ongoing trading fees

// 5. Register (as tokenAdmin)
ILevrFactory_v1.Project memory project = factory.register(clankerToken);
// Access: project.treasury, project.governor, project.staking, project.stakedToken
```

### Initialization Sequence

1. Forwarder deployed independently
2. Factory deployed with forwarder address
3. Treasury & Staking deployed via `prepareForDeployment()`
4. Clanker token deployed (uses treasury/staking addresses)
5. `register()` deploys governor & stakedToken, initializes all contracts
6. Governor set as treasury controller, staking linked to treasury

---

## Core Flows

### Staking

```
User stakes ‚Üí Staking escrows underlying, mints stakedToken 1:1
User unstakes ‚Üí Staking burns stakedToken, returns underlying
```

### Rewards (Manual Accrual System)

```
Clanker LP fees ‚Üí ClankerFeeLocker ‚Üí Manual accrual via accrueRewards()
Clanker airdrops ‚Üí Treasury
Manual rewards ‚Üí Transfer to staking ‚Üí accrueRewards(token, amount)
Governor proposes boost ‚Üí Treasury.applyBoost(amount)
Treasury ‚Üí Staking.accrueFromTreasury (measures delta, credits immediately)
Users claim ‚Üí Multi-token claim with reserve checks
```

### Governance

```
User (with minWTokenToSubmit) ‚Üí proposeTransfer or proposeBoost (custom amounts)
Validates: rolling windows, deadlines
Execute ‚Üí Treasury performs action (transfer or boost)
```

## Data Structures

```solidity
struct Project {
  address treasury;
  address governor;
  address staking;
  address stakedToken;
}

struct PreparedContracts {
  address treasury;
  address staking;
}
```

---

## Security

### Access Controls

| Function                         | Who Can Call                           |
| -------------------------------- | -------------------------------------- |
| `factory.prepareForDeployment()` | Anyone (tracked by deployer)           |
| `factory.register()`             | Only `clankerToken.tokenAdmin()`       |
| `treasury.transfer/applyBoost()` | Only governor                          |
| `governor.propose*()`            | Anyone with `minWTokenToSubmit` staked |
| `staking.stake/unstake/claim()`  | Anyone                                 |
| `staking.accrueRewards()`        | Anyone (manual accrual)                |
| `stakedToken.mint/burn()`        | Only staking                           |

### Protections

- **Reentrancy**: Guards on all treasury/staking external functions
- **Double Registration**: Prevented via `ALREADY_REGISTERED` check
- **Front-running**: Only deployer can use their prepared contracts
- **Reward Safety**: Reserve tracking prevents overdraw
- **No Owner on Treasury**: Governor controls all operations
- **Manual Accrual**: Explicit reward crediting prevents unexpected behavior

### Invariants

- StakedToken supply == total underlying staked
- Reward reserves >= pending claims
- One project per clankerToken
- Prepared contracts only usable by deployer

## Configuration

### Factory Config

- `protocolFeeBps` ‚Äî Protocol fee (basis points)
- `submissionDeadlineSeconds` ‚Äî Proposal deadline (7 days default)
- `streamWindowSeconds` ‚Äî Reward streaming (3 days default)
- `maxSubmissionPerType` ‚Äî Rate limit per proposal type (0 = unlimited)
- `minWTokenToSubmit` ‚Äî Min staked tokens to propose
- `protocolTreasury` ‚Äî Protocol treasury address

**Note**: `trustedForwarder` is NOT in config - must be deployed before factory

### Proposal Amounts

**Custom amounts**: No tiers - proposers specify exact amounts for transfers and boosts

### Meta-Transaction Forwarder

- **Implementation**: `LevrForwarder_v1` (extends OpenZeppelin's `ERC2771Forwarder`)
- **Deployment**: Must be deployed BEFORE factory
- **Name**: "LevrForwarder_v1"
- **Features**:
  - Standard ERC2771 meta-transaction support (via `execute()`)
  - **Multicall support** (via `executeMulticall()`) - execute multiple calls in ONE transaction
  - Signature verification and nonce management
- **Access**: `factory.trustedForwarder()` returns address
- **Immutable**: Cannot be changed after factory deployment
- **Shared**: All projects from same factory use same forwarder
- **Factory Support**: Factory itself supports meta-tx for `prepareForDeployment()` and `register()`

---

## Code Patterns

### Manual Reward Accrual

```solidity
// NEW: Manual accrual pattern
MockERC20 rewardToken = new MockERC20("Reward", "RWD");
rewardToken.mint(address(this), 1000 ether);

// Transfer tokens to staking
rewardToken.transfer(address(staking), 1000 ether);

// Manually accrue rewards (REQUIRED step)
staking.accrueRewards(address(rewardToken), 1000 ether);

// Now users can claim the rewards
address[] memory tokens = new address[](1);
tokens[0] = address(rewardToken);
staking.claimRewards(tokens, address(this));
```

### Registration

```solidity
// Deploy forwarder FIRST
LevrForwarder_v1 forwarder = new LevrForwarder_v1("LevrForwarder_v1");

// Factory setup with forwarder
LevrFactory_v1 factory = new LevrFactory_v1(config, owner, address(forwarder));

// Prepare before Clanker
(address treas, address stak) = factory.prepareForDeployment();

// Deploy Clanker (use treas & stak addresses)

// Register
ILevrFactory_v1.Project memory p = factory.register(clankerToken);
```

### Accessing Components

```solidity
ILevrFactory_v1.Project memory proj = factory.getProjectContracts(token);

LevrTreasury_v1(payable(proj.treasury));
LevrGovernor_v1(proj.governor);
LevrStaking_v1(proj.staking);
LevrStakedToken_v1(proj.stakedToken);
```

### Using Meta-Transactions

```solidity
// Users sign transactions, relayers execute
LevrForwarder_v1 forwarder = LevrForwarder_v1(factory.trustedForwarder());

// Example: Gasless stake
ERC2771Forwarder.ForwardRequestData memory request = ERC2771Forwarder.ForwardRequestData({
  from: user,
  to: address(staking),
  value: 0,
  gas: 300000,
  deadline: uint48(block.timestamp + 1 hours),
  data: abi.encodeWithSelector(LevrStaking_v1.stake.selector, amount),
  signature: userSignature
});

// Relayer executes (pays gas)
forwarder.execute(request);
```

### Chaining Transactions with Multicall

`LevrForwarder_v1.executeMulticall()` enables complex multi-step operations in ONE transaction:

```solidity
// Example: Complete project deployment - prepare + register in ONE transaction!
ILevrForwarder_v1.SingleCall[] memory calls = new ILevrForwarder_v1.SingleCall[](2);

// Call 1: Prepare deployment
calls[0] = ILevrForwarder_v1.SingleCall({
  target: address(factory),
  allowFailure: false,
  callData: abi.encodeWithSelector(LevrFactory_v1.prepareForDeployment.selector)
});

// Call 2: Register token
calls[1] = ILevrForwarder_v1.SingleCall({
  target: address(factory),
  allowFailure: false,
  callData: abi.encodeWithSelector(LevrFactory_v1.register.selector, clankerToken)
});

// Execute as user (multicall extracts user from msg.sender and appends to each call)
forwarder.executeMulticall(calls);
```

**Key Benefit**: User deploys entire project without paying gas - just signs off-chain!

### Creating New Contracts

**ALWAYS extend ERC2771ContextBase for user-facing contracts:**

```solidity
import {ERC2771ContextBase} from './base/ERC2771ContextBase.sol';

contract MyContract is ERC2771ContextBase {
  constructor(address trustedForwarder) ERC2771ContextBase(trustedForwarder) {}

  function myFunction() external {
    address realSender = _msgSender(); // NOT msg.sender!
    // ...
  }
}
```

**NEVER use `msg.sender` directly - always use `_msgSender()`**

---

## Testing

**Must Cover**:

- Security: Access controls, deployer tracking, meta-tx signature verification
- Flows: Stake ‚Üí Manual Accrue ‚Üí Claim ‚Üí Unstake (both direct and meta-tx)
- Governance: Proposals, custom amounts, execution, deadlines (gasless proposals)
- Rewards: Multi-token, reserves, streaming, manual accrual
- Meta-Transactions: Stake, unstake, claim, propose via forwarder
- ClankerFeeLocker: Automatic claiming integration
- Edge cases: Zero amounts, double registration, unauthorized calls
- Forwarder: `isTrustedForwarder()`, signature verification, nonce management

**Test Files**:

- `test/e2e/LevrV1.MetaTx.t.sol` - Meta-transaction tests
  - `test_MetaTx_Stake` - Gasless staking
  - `test_MetaTx_ProposeTransfer` - Gasless proposals
  - `test_MetaTx_Unstake` - Gasless unstaking
  - `test_MetaTx_Multicall_CompleteDeployment` - Full deployment via multicall (prepare ‚Üí register)
- `test/unit/LevrStakingV1.t.sol` - Pass `address(0)` for forwarder in unit tests if not testing meta-tx
  - `test_manual_reward_accrual_and_streaming` - Manual accrual flow testing

**Test Coverage for Manual Accrual**:

- Test reward transfer + manual accrual
- Test ClankerFeeLocker automatic claiming
- Test insufficient balance scenarios
- Test streaming after manual accrual

## Key Design Decisions

### Why Manual Reward Accrual?

- **Security**: Explicit control over reward crediting prevents unexpected behavior
- **Predictability**: No surprise reward accruals from arbitrary token transfers
- **Integration**: Better integration with ClankerFeeLocker automatic claiming
- **Simplicity**: Removes complex ERC1363 receiver logic

### Why No CREATE2 / Deterministic Addresses?

- **prepareForDeployment**: Simple `new Contract()` - no salting
- **register**: Deploys governor/stakedToken without salts
- **Reason**: Addresses don't need prediction - treasury/staking exist before Clanker

### Why No Ownable on Treasury?

- **Governor controls all operations** via `onlyGovernor` modifier
- **Register is gated** by `tokenAdmin` check - no front-running
- **Simpler, cleaner** - one less security layer to manage

### Why Auto-Lookup of Prepared Contracts?

- **Mapping tracks deployer** ‚Üí `PreparedContracts{treasury, staking}`
- **register() auto-uses** prepared contracts from `msg.sender`
- **Security**: Only deployer can use their contracts (no parameters to hijack)

### Why Return Project Struct?

- **Cleaner API**: One struct vs four separate addresses
- **Type safety**: All addresses grouped logically
- **Easier usage**: `proj.treasury` vs destructuring

### Why Forwarder Deployed Before Factory?

- **Factory Meta-TX Support**: Factory needs to extend ERC2771Context to support meta-tx on `prepareForDeployment()` and `register()`
- **Constructor Limitation**: Can't deploy forwarder in constructor if factory extends ERC2771Context
- **Security**: Immutable, can't be changed after deployment
- **Consistency**: All projects from same factory share same forwarder
- **Standard**: Uses OpenZeppelin's battle-tested `ERC2771Forwarder`
- **Factory Functions**: `prepareForDeployment()` and `register()` use `_msgSender()` for meta-tx support

### Why ERC2771ContextBase Base Contract?

- **DRY Principle**: Eliminates ~135 lines of duplicated override code
- **Maintainability**: One place to update ERC2771 logic
- **Multiple Inheritance**: Cleanly resolves ReentrancyGuard + ERC2771Context diamond pattern
- **Type Safety**: Enforces consistent meta-transaction handling

**Note**: Factory extends `ERC2771Context` directly and implements its own overrides because Solidity's override specification doesn't allow inheriting through abstract base contracts in complex diamond patterns.

### Why executeTransaction on Factory?

- **Multicall Composition**: Enables complex transaction chains via forwarder
- **Flexible Routing**: Factory can execute arbitrary calls in multicall sequences
- **Gas Efficiency**: Single meta-tx signature covers multiple operations
- **Public Access**: No restrictions - useful for composability
- **Reentrancy Protected**: Uses ReentrancyGuard for safety

---

## Changes from Previous Versions

### Removed

- ‚ùå **ERC1363 auto-accrual** - No automatic reward crediting on token transfers
- ‚ùå `IERC1363Receiver` implementation - Staking no longer implements this interface
- ‚ùå `onTransferReceived()` functionality - Manual accrual required
- ‚ùå `transferAndCall()` support - Use regular transfers + manual accrual
- ‚ùå `MockERC1363` test utilities - Replaced with standard ERC20 testing
- ‚ùå `registerDryRun()` - unreliable prediction
- ‚ùå CREATE2 salting - not needed
- ‚ùå Treasury `Ownable` - redundant
- ‚ùå Multiple return values - now returns struct
- ‚ùå Treasury/staking params in register - auto-lookup
- ‚ùå Tier system - replaced with custom amounts

### Added

- ‚úÖ **Manual reward accrual system** - Explicit `accrueRewards()` calls required
- ‚úÖ **ClankerFeeLocker integration** - Automatic claiming before manual accrual
- ‚úÖ `outstandingRewards()` - Check available and pending rewards
- ‚úÖ `_claimFromClankerFeeLocker()` - Internal automatic claiming
- ‚úÖ `_getPendingFromClankerFeeLocker()` - Check pending fees
- ‚úÖ `prepareForDeployment()` - pre-deploy infrastructure
- ‚úÖ Deployer tracking - security via mapping
- ‚úÖ `Project` struct returns - cleaner API
- ‚úÖ Auto-lookup prepared contracts
- ‚úÖ Treasury receives airdrops, Staking receives fees (split roles)
- ‚úÖ Custom proposal amounts - no tier restrictions
- ‚úÖ **ERC2771 meta-transaction support** - gasless transactions via forwarder
- ‚úÖ **ERC2771ContextBase** - base contract eliminates duplication
- ‚úÖ **executeTransaction** - factory function for multicall composition

---

## Critical Patterns and Anti-Patterns

### ‚úÖ DO

- **ALWAYS** use manual reward accrual: transfer tokens + `accrueRewards()`
- **ALWAYS** use `_msgSender()` instead of `msg.sender` in user-facing contracts
- **ALWAYS** extend `ERC2771ContextBase` for new contracts that need meta-tx support (except factory)
- **ALWAYS** deploy forwarder BEFORE factory
- **ALWAYS** pass `trustedForwarder` to contract constructors
- **ALWAYS** update this documentation when making architectural changes
- **CONSIDER** using `factory.executeTransaction()` for complex multicall sequences

### ‚ùå DON'T

- **NEVER** expect automatic reward accrual on token transfers
- **NEVER** use `transferAndCall()` - use transfer + `accrueRewards()`
- **NEVER** implement `IERC1363Receiver` - manual accrual only
- **NEVER** use `msg.sender` directly in contracts that extend ERC2771ContextBase or ERC2771Context
- **NEVER** create custom forwarders - use OpenZeppelin's `ERC2771Forwarder`
- **NEVER** manually override `_msgSender()/_msgData()/_contextSuffixLength()` - use base contract (except factory)
- **NEVER** forget to pass `address(0)` for forwarder in unit tests if not testing meta-tx
- **NEVER** let this documentation become outdated
- **NEVER** deploy factory before deploying forwarder
- **AVOID** using `executeTransaction` for operations requiring specific caller identity

---

## File Structure

```
src/
  base/
    ERC2771ContextBase.sol         # Base contract for meta-tx support
  LevrFactory_v1.sol                # Factory (extends ERC2771Context directly)
  LevrTreasury_v1.sol               # Extends ERC2771ContextBase
  LevrGovernor_v1.sol               # Extends ERC2771ContextBase
  LevrStaking_v1.sol                # Extends ERC2771ContextBase (NO ERC1363)
  LevrStakedToken_v1.sol            # No meta-tx (not user-facing)
  LevrForwarder_v1.sol              # Meta-transaction forwarder
  interfaces/
    ILevrFactory_v1.sol             # Factory interface
    ILevrGovernor_v1.sol            # Governor interface
    ILevrStaking_v1.sol             # Staking interface
    ILevrTreasury_v1.sol            # Treasury interface
    ILevrStakedToken_v1.sol         # StakedToken interface
    ILevrForwarder_v1.sol           # Forwarder interface
    external/
      IClankerFeeLocker.sol         # ClankerFeeLocker interface

test/
  e2e/
    LevrV1.Governance.t.sol
    LevrV1.Registration.t.sol
    LevrV1.Treasury.t.sol
  unit/
    LevrFactoryV1.*.t.sol
    LevrGovernorV1.t.sol
    LevrStakingV1.t.sol             # Updated for manual accrual
    LevrTreasuryV1.t.sol
    LevrStakedTokenV1.t.sol
  mocks/
    MockERC20.sol                   # Standard ERC20 mock (ERC1363 removed)
```

---

**This rule is normative. All contract code must align with these specifications.**

**‚ö†Ô∏è REMEMBER: Update this rule immediately when making any changes! ‚ö†Ô∏è**

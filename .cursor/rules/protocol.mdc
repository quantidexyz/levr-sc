---
alwaysApply: true
---

## Levr Protocol v1 — Contracts Architecture

This document defines the contract architecture and implementation details for Levr Protocol v1, focusing on the modular contract system with factory, treasury, governor, staking module, and staked token components. It is the source-of-truth for contract implementations and integration decisions.

### Scope and Compatibility

- **Protocol version**: v1
- **Architecture**: Modular system with `LevrFactory_v1` as the entry point, deploying per-project `LevrTreasury_v1`, `LevrGovernor_v1`, `LevrStaking_v1`, and `LevrStakedToken_v1`.

---

### Core Contract Entities

#### LevrFactory_v1

- **Role**: Global configuration owner and deployment/registry entrypoint for projects
- **Responsibilities**:
  - Deploy/clone per-project contracts (`LevrTreasury_v1`, `LevrGovernor_v1`, `LevrStaking_v1`, `LevrStakedToken_v1`)
  - Manage protocol-wide configuration (fees, limits, tiers, deadlines)
  - Register projects (treasury always deployed fresh per registration)

- **Key Storage**:
  - `protocolFeeBps`: Fee in basis points for mint/redeem operations
  - `submissionDeadlineSeconds`: Proposal deadline (default 7 days)
  - `maxSubmissionPerType`: Max proposals per type per 7-day window
  - `stakingBoostTiers`, `transferTiers`: Governance tier configurations
- `minWTokenToSubmit`: Minimum staked token balance to submit proposals
  - `protocolTreasury`: Protocol fee recipient address
  - Contract implementation addresses for cloning

#### LevrTreasury_v1 (Per-Project)

- **Role**: Custody and execution contract for project assets and governance decisions
- **Responsibilities**:
  - Hold underlying reserve tokens and receive Clanker airdrops/fees
  - Execute transfers authorized by governor
  - Apply boosts by moving tokens to staking and accruing rewards

- **Key Storage**:
  - `underlying`: Address of the Clanker token
  - `governor`: Address of the project's governor contract
  - (no wrapper)

#### LevrGovernor_v1 (Per-Project)

- **Role**: Governance and proposal execution for project treasury decisions
- **Responsibilities**:
  - Handle proposal submissions (transfer requests, staking boosts)
  - Enforce submission limits, deadlines, and tier constraints
  - Execute approved proposals on the treasury

- **Key Storage**:
  - Active proposals with metadata (type, amounts, deadlines, tiers)
  - Rolling counters for submission rate limiting
  - Proposal execution state and voting records

#### LevrStaking_v1 (Per-Project)

- **Role**: Escrows underlying stakes and manages multi-token reward accrual and claims
- **Responsibilities**:
  - Stake/unstake underlying; mint/burn `LevrStakedToken_v1` 1:1
  - Accrue rewards per token via `accrueRewards` or `accrueFromTreasury` using delta-based accounting
  - Maintain per-token reward reserves to prevent double counting; decrement reserves on claim
  - Guard claims with liquidity checks to avoid overdrawing rewards
  - Claim rewards per token to a recipient

#### LevrStakedToken_v1 (Per-Project)

- **Role**: 1:1 staked token representing staked balances; governance weight source

---

### Contract Interactions and Flow

#### Project Registration

1. **External Call**: `LevrFactory_v1.register(clankerToken)`
   - **Access Control**: Only callable by `clankerToken.tokenAdmin()`
   - Validates clankerToken exists and is properly configured
   - No treasury reuse; always deploys fresh treasury

2. **Contract Deployment** (CREATE2-based):
   - Deploy new `LevrTreasury_v1` using CREATE2 with `clankerToken` address as salt
   - Deploy `LevrStaking_v1` using CREATE2 with same base salt
   - Deploy `LevrStakedToken_v1` using CREATE2 with derived salt (`keccak256(baseSalt, 'stakedToken')`)
   - Deploy `LevrGovernor_v1` using CREATE2 with derived salt (`keccak256(baseSalt, 'governor')`)

3. **Initialization**:
   - Treasury: Set governor and underlying addresses
   - Governor: Set treasury address and factory config reference
   - Staking: Initialize with underlying and staked token; staking controls staked token mint/burn

4. **Treasury Address Prediction** (via `registerDryRun`):
   - **Deterministic**: Treasury address is fully deterministic based on `clankerToken` address
   - **Time-Independent**: Addresses can be predicted at any time before registration
   - **Method**: Call `factory.registerDryRun(clankerToken)` to get all four addresses
   - **Use Case**: Allows setting treasury as Clanker fee/airdrop recipient before registration
   - **CREATE2 Salt**: Uses `bytes32(uint256(uint160(clankerToken)))` as base salt
   - **Stability**: Same token always produces same addresses regardless of factory state

#### Staking and Boost Flows

**Stake/Unstake**:

```
User → Underlying.transferFrom(user, staking, amount)
Staking → mint sToken 1:1 to user

User → burn sToken
Staking → transfer underlying back to user
```

**Airdrop/Boost**:

```
Clanker → Treasury (fees/airdrops)
Governor → Treasury.applyBoost(amount)
Treasury → Staking.accrueFromTreasury(underlying, amount, pull=true)
Staking → measures actual received delta and immediately credits rewards; no external sync required
Staking → accPerShare[underlying] += delta / totalStaked; stream window resets using delta
```

Notes on Clanker airdrops (as used in E2E tests):

- ClankerAirdrop leaf format (deployed extension): `keccak256(bytes.concat(keccak256(abi.encode(recipient, amount))))`.
- Our tests construct a single-leaf Merkle root for the treasury as the sole recipient and pass the root via the extension data.
- Extension data encoding used: `(admin, merkleRoot, lockupDuration, vestingDuration)`; lockup must be ≥ 1 day.
- Claims are triggered via `IClankerAirdrop.claim(token, recipient, allocatedAmount, proof)`; for single-leaf trees the proof is empty.
- Helper: `test/utils/MerkleAirdropHelper.sol` exposes `singleLeafRoot(recipient, amount)` that builds the double-hash leaf root.

#### Governance Proposals

**Proposal Creation**:

- Validate `msg.sender` holds ≥ `minWTokenToSubmit` staked tokens
- Check rolling submission limits per type (7-day windows)
- Validate amount constraints against selected tier
- Store proposal with deadline (`block.timestamp + submissionDeadlineSeconds`)

**Proposal Execution**:

- Verify proposal deadline not exceeded
- Execute treasury action based on proposal type
- Update rolling counters and emit events

---

### Fee Model and Accounting

#### Fees

- **Protocol Fee**: `protocolFeeBps / 10000` of operation amount on applicable actions (forwarded to protocol treasury)

#### Rounding and Precision

- Use conservative rounding favoring reserves safety
- Track reward reserves at staking per token to avoid double-accounting
- Track fee accumulations in project treasury for governance distribution
- Emit fee collection events for transparency

#### Invariants

- Staked token total supply equals total underlying staked
- Protocol fees forwarded correctly to protocol treasury (no project fee path)
- Governance proposals execute atomically with proper access controls
- Reward claims cannot exceed tracked reserves (revert on insufficient liquidity)
- Treasury balance ≥ sum of governance-allocated amounts

---

### Governance: Submission Limits and Tiers

#### Global Configuration (Factory Level)

- `submissionDeadlineSeconds: uint32` — Common deadline for all proposal types (default: 604,800 = 7 days)
- `maxSubmissionPerType: uint16` — Max proposals per type per rolling 7-day window
- `minWTokenToSubmit: uint256` — Minimum wrapper balance required to submit proposals

#### Tier Definitions

**Transfer Tiers** (absolute amounts in underlying units):

- `low`, `mid`, `high`: Maximum transfer amounts per proposal

**Staking Boost Tiers** (fraction of treasury or emissions):

- `low`, `mid`, `high`: Boost percentages (e.g., 0.03, 0.6, 0.9)

#### Rolling Window Enforcement

- Track submissions per `(projectId, proposalType, weekStart)` mapping
- Use `block.timestamp / 604800` for week calculation
- Revert if `currentCount >= maxSubmissionPerType`

---

### Security Considerations

#### Access Control

- **Factory**: Only owner can update global configuration; `register` callable only by `clankerToken.tokenAdmin()`
- **Treasury**: Only governor can execute transfers and boosts
- **Governor**: Only staked token holders meeting minimum balance can propose
- **Staked Token**: Staking contract has exclusive mint/burn rights

#### Reentrancy Protection

- Non-reentrant guards on all external treasury functions and staking accrual paths
- Stake/unstake operations use checks-effects-interactions pattern
- Reward accrual and claims protected against reentrancy
- Balance checks completed before token transfers

#### Input Validation

- All addresses validated as non-zero
- Amounts checked against tier limits and balance availability
- Deadline calculations prevent overflow/underflow

#### Emergency Controls

- Factory owner can pause registrations if needed
- Treasury includes emergency withdrawal mechanisms (governance-controlled)
- Staking includes optional pauser role for extreme circumstances

---

### Contract Interfaces (Implementation Requirements)

#### LevrFactory_v1

```solidity
interface ILevrFactory_v1 {
    function register(
        address clankerToken
    ) external returns (address treasury, address governor, address staking, address stakedToken);

    function registerDryRun(
        address clankerToken
    ) external view returns (address treasury, address governor, address staking, address stakedToken);

    function updateConfig(FactoryConfig calldata cfg) external;

    function getProjectContracts(address clankerToken)
        external view returns (address treasury, address governor, address staking, address stakedToken);

    function streamWindowSeconds() external view returns (uint32);
}

struct FactoryConfig {
    uint16 protocolFeeBps;
    uint32 submissionDeadlineSeconds;
    uint16 maxSubmissionPerType;
    uint32 streamWindowSeconds;
    TierConfig[] transferTiers;
    TierConfig[] stakingBoostTiers;
    uint256 minWTokenToSubmit;
    address protocolTreasury;
}
```

**Key Function Details**:

- **`register`**: Deploys all project contracts using CREATE2 with deterministic addresses
  - Only callable by `clankerToken.tokenAdmin()`
  - Uses token address as base salt for CREATE2 deployments
  - Returns addresses of all deployed contracts

- **`registerDryRun`**: Predicts deployment addresses without authorization checks
  - View function, safe to call at any time
  - Uses CREATE2 address computation with token metadata
  - Queries token metadata (name, symbol, decimals, admin) for accurate predictions
  - Same token always returns same addresses

#### LevrTreasury_v1

```solidity
interface ILevrTreasury_v1 {
    function transfer(address to, uint256 amount) external;
    function applyBoost(uint256 amount) external;
    function getUnderlyingBalance() external view returns (uint256);
    function underlying() external view returns (address);
}
```

#### LevrGovernor_v1

```solidity
interface ILevrGovernor_v1 {
    function proposeTransfer(
        address receiver,
        uint256 amount,
        string calldata reason,
        uint8 tier
    ) external returns (uint256 proposalId);

    function proposeBoost(
        uint256 amount,
        uint8 tier
    ) external returns (uint256 proposalId);

    function execute(uint256 proposalId) external;

    function getProposal(uint256 proposalId)
        external view returns (Proposal memory);

    function canSubmit(address proposer) external view returns (bool);
}

struct Proposal {
    address proposer;
    ProposalType proposalType;
    address receiver;
    uint256 amount;
    string reason;
    uint8 tier;
    uint32 deadline;
    bool executed;
}
```

#### LevrStaking_v1

```solidity
interface ILevrStaking_v1 {
    function stake(uint256 amount) external;
    function unstake(uint256 amount, address to) external;

    function accrueRewards(address token, uint256 amount) external;
    function accrueFromTreasury(address token, uint256 amount, bool pull) external;

    function claimRewards(address[] calldata tokens, address to) external;

    function totalStaked() external view returns (uint256);
    function stakedToken() external view returns (address);
    function underlying() external view returns (address);
}
```

#### LevrStakedToken_v1

```solidity
interface ILevrStakedToken_v1 is IERC20 {
    function mint(address to, uint256 amount) external;
    function burn(address from, uint256 amount) external;

    function decimals() external view returns (uint8);
    function underlying() external view returns (address);
}
```

Note: Mint/burn functions are exclusively callable by the associated `LevrStaking_v1` contract.

---

### Implementation Patterns and Best Practices

#### Contract Deployment

- Use CREATE2 for deterministic deployment addresses based on token address
- Base salt: `bytes32(uint256(uint160(clankerToken)))`
- Derived salts for stakedToken and governor: `keccak256(abi.encodePacked(baseSalt, 'stakedToken'))` / `'governor'`
- Initialize contracts with immutable references to avoid storage costs
- Validate all constructor parameters and relationships
- Same token address always deploys to same addresses (prevents duplicate registrations)

#### Storage Optimization

- Pack related variables into single slots where possible
- Use mappings for per-user/project data to avoid iteration
- Cache frequently accessed factory config in governor contracts

#### Event Emission

- Emit comprehensive events for all state changes
- Include indexed parameters for efficient off-chain querying
- Follow ERC-20/ERC-721 event standards where applicable

#### Error Handling

- Use custom errors instead of string reverts for gas efficiency
- Provide descriptive error messages for debugging
- Validate inputs at function boundaries

---

### Testing Guidance (Contract-Focused)

#### Unit Tests

- Test all fee calculations and edge cases (rounding, overflow)
- Validate tier enforcement and submission limits
- Test proposal lifecycle (create → execute → cleanup)
- Verify access controls and permission boundaries

#### Integration Tests

- End-to-end stake/unstake flows with reward accrual
- Governance proposal creation and execution
- Multi-project registration and isolation
- Emergency controls and pause functionality

#### Invariant Tests

- Staked token supply equals total staked underlying
- Reward reserves properly tracked per token
- Governance proposals execute atomically
- Rolling counters accurately track submission limits

#### Fuzz Tests

- Random fee configurations and tier selections
- Arbitrary proposal amounts and deadlines
- Concurrent operations and reentrancy attempts
- Edge case amounts (0, max uint256, etc.)

---

### Migration and Deployment Notes

- **From v1**: No automatic migration path; v1 requires fresh deployment
- **Contract Verification**: All contracts should be verified on deployment networks
- **Proxy Patterns**: Consider upgradeable proxies for critical infrastructure contracts
- **Initialization**: Ensure proper initialization order and validation

---

### Key Changes from Prior Versions

#### Removed

- ❌ `deployTreasury()` function (treasury always deployed via `register`)
- ❌ `treasuryAddress` constructor param
- ❌ `RegisterParams` struct entirely (register takes only clankerToken parameter)
- ❌ Treasury fallback logic (no reusing existing treasuries)
- ❌ Wrapper token (direct staking of underlying)
- ❌ Nonce-based address prediction (replaced with CREATE2)

#### Added

- ✅ `tokenAdmin` gating on `register` (only token admin can register)
- ✅ **CREATE2-based deterministic deployment** - addresses based on token address
- ✅ **`registerDryRun` function** - predict addresses at any time before registration
- ✅ Staking-based governance (no wrapper intermediary)
- ✅ Multi-token reward accounting
- ✅ ERC-1363 auto-credit for reward tokens
- ✅ Time-independent address prediction (stable regardless of factory state)
- ✅ Sub-salt derivation for stakedToken and governor to prevent collisions

---

This rule is normative for contract implementations. All contract code should align with the above specifications. Any architectural changes should update this document first.

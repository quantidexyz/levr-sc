---
alwaysApply: true
---

## Levr Protocol Rules — MasterLevr v1 (Monolithic Architecture)

This document defines how the Levr protocol operates in a monolithic setup centered on `MasterLevr_v1`, including ERC20 wrapper tokens, solvency (FCFS redemptions), staking, fee distribution from Clanker v4 pools, and observability (peg, APY). It is source-of-truth for integration and implementation decisions across the codebase.

### Scope

- Single `MasterLevr_v1` contract orchestrates:
  - Registration of Clanker-launched tokens and associated v4 pool identity
  - Wrapping via per-pool ERC20 issuance tokens (OpenZeppelin-based)
  - Mint/redeem flows with underlying escrow held by `MasterLevr_v1`
  - Staking of the wrapped token and reward distribution
  - Harvesting protocol fees from Clanker v4 `IPoolManager`
  - Peg and APY tracking (read-only views)

## Components and Roles

### MasterLevr_v1

- Stores per-pool configuration and accounting in a mapping from `levrId` to a struct. The canonical keys include:

  - `underlying`: Clanker-launched ERC20 address
  - `wrapper`: ERC20 issuance token address (OpenZeppelin-based), 1:1 unit mapping to underlying
  - `poolManager`: v4 `IPoolManager` address
  - `poolKeyEncoded`: `abi.encode(PoolKey)` for the v4 pool; used to derive `PoolId`
  - `poolId`: derived v4 `PoolId`
  - `underlyingEscrowed`: total underlying tokens currently escrowed in `MasterLevr_v1`
  - `syntheticSupply`: wrapper total supply mirror (sanity check; read from wrapper if needed)
  - `stakedSupply`: total wrapper tokens staked in `MasterLevr_v1`
  - `rewardIndexX64`: global rewards accumulator (Q64 fixed-point)
  - `lastHarvest`: last harvest timestamp

- Global mappings:

  - `levrIdByUnderlying[underlying] -> levrId`
  - `levr[levrId] -> LevrPool`
  - `userStake[levrId][user]`, `userIndexX64[levrId][user]`, `userClaimable[levrId][user]`

- Authority:
  - Acts as protocol fee controller for relevant pools, or is configured as the collector via governance.
  - Is a designated minter/burner of each `wrapper` token.

### ERC20 Issuance Token (Wrapper)

- Standard OpenZeppelin ERC20 with AccessControl.

  - `DEFAULT_ADMIN_ROLE`: deployer of the wrapper (project owner)
  - `MINTER_ROLE`: granted to `MasterLevr_v1` and also to the deployer
  - Optional `PAUSER_ROLE` if we include pausability

- Behavior:

  - `mint(address to, uint256 amount)`: restricted to `MINTER_ROLE`
  - `burn(address from, uint256 amount)`: restricted to `MINTER_ROLE` (for redemptions via MasterLevr), or `burn(uint256)` for self-burn if enabled
  - Decimals should mirror the underlying token’s decimals
  - Name/Symbol: may encode the underlying identity, e.g., `<SYMBOL>W` or `w<SYMBOL>`

- Ownership and Roles:
  - The wrapper deployer retains admin rights and has `MINTER_ROLE` so they can mint at their discretion
  - `MasterLevr_v1` also has `MINTER_ROLE` to handle user mint/redeem and staking flows

## Registration (Fresh or Existing; Only MasterLevr Address Known)

1. Token deployer creates the Clanker token using the Clanker SDK, ensuring `MasterLevr_v1` will be the protocol fee controller or collector for the pool (via factory/hook configuration where applicable).

2. Anyone can call `registerPool` on `MasterLevr_v1` with:

   - `underlying` address
   - `poolManager` address (v4 core)
   - `poolKeyEncoded` (ABI-encoded `PoolKey`) or enough parameters to build it
   - Optionally, wrapper metadata (name, symbol, decimals) if not inferred

3. `MasterLevr_v1` computes `PoolId`, stores config, and deploys or wires the ERC20 wrapper token for this `underlying`:
   - Grants `MINTER_ROLE` to `MasterLevr_v1` and to the deployer/admin
   - Persists `levrIdByUnderlying` and `levr[levrId]`

From this point forward, all flows are available with only the `MasterLevr_v1` address known to participants.

Applies to both freshly deployed and already-launched Clanker tokens:

- For existing tokens, callers provide the live pool identifiers to `registerPool` and the flow is identical.
- Holder migration is not required; users can deposit underlying to mint the wrapper 1:1 at any time.
- Deployers may seed `underlyingEscrowed` by transferring underlying to `MasterLevr_v1`.

## Mint / Redeem and Escrow Solvency (FCFS)

- Underlying escrow is maintained entirely inside `MasterLevr_v1`.

  - User mint: user transfers `amount` of underlying to `MasterLevr_v1`; `MasterLevr_v1` mints `amount` of wrapper to the recipient and increments `underlyingEscrowed`.
  - User redeem: user submits `amount` of wrapper to `MasterLevr_v1`; `MasterLevr_v1` burns the wrapper and transfers up to `amount` of underlying out of escrow.

- Deployer mint freedom:

  - Because the deployer has `MINTER_ROLE`, they can mint wrapper beyond current escrow levels.
  - The protocol adopts First-Come-First-Served (FCFS) solvency for redemptions:
    - Redemptions are fulfilled strictly from `underlyingEscrowed`
    - If `underlyingEscrowed < redeemAmount`, the transaction reverts (or partially fulfills if explicitly supported) — there is no debt queuing.
    - Users who redeem earlier are prioritized; once escrow is depleted, later redeemers must wait for additional deposits/harvests.

- Invariants and tracking:

  - `pegRatioBps = underlyingEscrowed * 1e4 / wrapper.totalSupply()`
  - Frontends should surface solvency and peg ratio for transparency.

- Events (recommended):
  - `Minted(levrId, user, amountUnderlying, amountWrapper)`
  - `Redeemed(levrId, user, amountWrapper, amountUnderlyingPaid)`
  - `SolvencyChanged(levrId, underlyingEscrowed, wrapperSupply)`

## Staking and Rewards (Fee Distribution)

- Users can stake their wrapper tokens in `MasterLevr_v1` to earn fees harvested from the associated v4 pool.

- Reward accounting uses a global index per pool:

  - `rewardIndexX64` accumulates as `harvestAmount << 64 / stakedSupply`
  - Each user tracks `userIndexX64` at stake/unstake/claim boundaries
  - `claimable += (userStake * (rewardIndexX64 - userIndexX64)) >> 64`

- Core methods:
  - `stake(levrId, amount, to)`
  - `unstake(levrId, amount, to)`
  - `claim(levrId, to)` — pays out the fee currency accrued for that pool (typically the paired token or underlying per configuration)

## Fee Harvesting from Clanker v4

- `MasterLevr_v1` is configured as the protocol fee controller/collector for the pool.
- Anyone may call `harvest(levrId)` to collect protocol fees using v4 unlock discipline:
  - Calls `IPoolManager.unlock` with a callback that executes `collectProtocolFees(recipient=MasterLevr_v1, currency, amount)`
  - Ensures settlement nets to zero prior to re-locking; otherwise reverts per v4 constraints
  - On success, credits the harvested amounts into the pool’s reward accounting and updates `rewardIndexX64`

### Fee Permissions

- Choose one path to enable fee collection attribution:

  1. Controller handoff (preferred): set `MasterLevr_v1` as the protocol fee controller for the pool so `harvest(levrId)` can directly collect fees.
  2. Extension metering: attach an allowlisted pool extension that calls `MasterLevr_v1.reportProtocolFee(poolId, amount0, amount1)` on each swap; `harvest(levrId)` collects up to the tracked entitlement.
  3. Isolation: use a dedicated `IPoolManager` instance so currency buckets are not shared with unrelated pools.
  4. Exclusivity: enforce that no two registered pools share the same fee currency on the same manager.

- If the controller cannot be changed and no extension is present, wrapping, mint/redeem, and staking still function; fee distribution is disabled until fees can be attributed/collected. UIs should display the fee status accordingly.

### Fee Attribution and Shared Currency Buckets

- Attribution model:

  - Fees are not pushed to `MasterLevr_v1`; they are pulled per-pool via `harvest(levrId)`.
  - Attribution is by call context: during `harvest(levrId)`, the contract collects only the currencies that belong to that pool’s `PoolKey` and immediately credits them to that `levrId`’s reward index.

- Shared currency buckets on the same `IPoolManager`:

  - Because `protocolFeesAccrued(currency)` is aggregated per currency (not per pool), avoid ambiguity by one of the following patterns:
    1. Pool-extension metering (recommended): a Clanker pool extension invokes `MasterLevr_v1.reportProtocolFee(poolId, amount0, amount1)` on each swap to track per-pool entitlements. On `harvest(levrId)`, allocate from the global currency bucket up to the owed entitlement for that `poolId`.
    2. Isolation: use a dedicated `IPoolManager` (or deployment) for registered pools so currency buckets are not shared with unrelated pools.
    3. Exclusivity: enforce a registry invariant that no two registered pools share the same fee currency on the same manager (e.g., `currency -> levrId` map) to prevent ambiguous attribution.

- If none of the above are enforced and multiple pools share a currency bucket, `harvest(levrId)` must conservatively cap collection to the pool’s tracked entitlement (if any); otherwise, harvesting could misattribute fees. Frontends should surface which strategy is active.

## Peg and APY Observability

- Expose read-only views per pool:

  - `getPegBps(levrId) -> uint256`: `underlyingEscrowed * 1e4 / wrapper.totalSupply()` (returns 0 if supply is 0)
  - `getRatePerSecondX64(levrId) -> uint256`: rolling rewards rate for frontends to annualize
  - Optionally provide windowed averages over the last N seconds/harvests

- APY is an off-chain presentation: `ratePerSecond * 31,536,000` as a baseline, with caveats on variable fees/TVL.

## Security, Roles, and Constraints

- Roles:

  - Wrapper `DEFAULT_ADMIN_ROLE`: deployer
  - Wrapper `MINTER_ROLE`: deployer and `MasterLevr_v1`
  - Optionally gate `registerPool` behind governance or allow anyone with guardrails (immutability of keys once set)

- Constraints:

  - `MasterLevr_v1` must have permission to collect protocol fees for a pool; otherwise harvesting is impossible
  - Address ordering and `PoolKey` correctness are enforced by v4 (`currency0 < currency1`, valid tick spacing)
  - Dynamic fee/MEV caps are respected by the underlying hook; not modified by `MasterLevr_v1` unless explicitly supported
  - FCFS solvency means no redemption guarantees if deployers over-mint — frontends and docs must warn users

- Safety:
  - Adhere to v4 unlock discipline; ensure currency settlement nets to zero before re-locking
  - Track and emit events for registration, mint, redeem, stake, unstake, claim, harvest
  - Consider reentrancy guards around state mutations and external transfers

## Minimal External Interface (Indicative)

```solidity
// Registration
function registerPool(
    address underlying,
    address poolManager,
    bytes calldata poolKeyEncoded,
    string calldata name,
    string calldata symbol
) external returns (uint256 levrId, address wrapper);

// Mint/Redeem (user flows)
function mint(uint256 levrId, uint256 amountUnderlying, address to) external;
function redeem(uint256 levrId, uint256 amountWrapper, address to) external;

// Staking
function stake(uint256 levrId, uint256 amount, address to) external;
function unstake(uint256 levrId, uint256 amount, address to) external;
function claim(uint256 levrId, address to) external;

// Fees
function harvest(uint256 levrId) external;

// Views
function getPegBps(uint256 levrId) external view returns (uint256);
function getRatePerSecondX64(uint256 levrId) external view returns (uint256);
```

## Implementation Notes

- Wrapper deployment can be minimal proxies (clones) pointing to a single ERC20 implementation to keep gas low while maintaining per-pool metadata and role configuration.
- Wrapper decimals should mirror the underlying token to preserve 1:1 unit expectations.
- Peg ratio and solvency should be surfaced in UIs prominently, with FCFS caveats.
- If partial redemption is supported, define and emit `Redeemed` with the actual fulfilled amount; otherwise revert on insufficient escrow.

## Clanker v4 Integration Reminders

- `MasterLevr_v1` should be set as protocol fee controller (or have the appropriate permissions) during Clanker SDK deployment.
- Use `IPoolManager.collectProtocolFees` inside an `unlock` flow to harvest and credit rewards.
- Optional reads for UI/analytics:
  - `IClankerHookDynamicFee.poolConfigVars(poolId)` / `poolFeeVars(poolId)`
  - `IClankerHookV2.mevModuleOperational(poolId)` / `mevModuleEnabled(poolId)`
  - `IPoolManager.protocolFeesAccrued(currency)` / `protocolFeeController()`

---

This rule is normative. Contract implementations and SDK integrations should align with the above semantics. Any divergence should update this document first.

## Levr Protocol Rules — MasterLevr v1 (Monolithic Architecture)

This document defines how the Levr protocol operates in a monolithic setup centered on `MasterLevr_v1`, including ERC20 wrapper tokens, solvency (FCFS redemptions), staking, fee distribution from Clanker v4 pools, and observability (peg, APY). It is source-of-truth for integration and implementation decisions across the codebase.

### Scope

- Single `MasterLevr_v1` contract orchestrates:
  - Registration of Clanker-launched tokens and associated v4 pool identity
  - Wrapping via per-pool ERC20 issuance tokens (OpenZeppelin-based)
  - Mint/redeem flows with underlying escrow held by `MasterLevr_v1`
  - Staking of the wrapped token and reward distribution
  - Harvesting protocol fees from Clanker v4 `IPoolManager`
  - Peg and APY tracking (read-only views)

## Components and Roles

### MasterLevr_v1

- Stores per-pool configuration and accounting in a mapping from `levrId` to a struct. The canonical keys include:

  - `underlying`: Clanker-launched ERC20 address
  - `wrapper`: ERC20 issuance token address (OpenZeppelin-based), 1:1 unit mapping to underlying
  - `poolManager`: v4 `IPoolManager` address
  - `poolKeyEncoded`: `abi.encode(PoolKey)` for the v4 pool; used to derive `PoolId`
  - `poolId`: derived v4 `PoolId`
  - `underlyingEscrowed`: total underlying tokens currently escrowed in `MasterLevr_v1`
  - `syntheticSupply`: wrapper total supply mirror (sanity check; read from wrapper if needed)
  - `stakedSupply`: total wrapper tokens staked in `MasterLevr_v1`
  - `rewardIndexX64`: global rewards accumulator (Q64 fixed-point)
  - `lastHarvest`: last harvest timestamp

- Global mappings:

  - `levrIdByUnderlying[underlying] -> levrId`
  - `levr[levrId] -> LevrPool`
  - `userStake[levrId][user]`, `userIndexX64[levrId][user]`, `userClaimable[levrId][user]`

- Authority:
  - Acts as protocol fee controller for relevant pools, or is configured as the collector via governance.
  - Is a designated minter/burner of each `wrapper` token.

### ERC20 Issuance Token (Wrapper)

- Standard OpenZeppelin ERC20 with AccessControl.

  - `DEFAULT_ADMIN_ROLE`: deployer of the wrapper (project owner)
  - `MINTER_ROLE`: granted to `MasterLevr_v1` and also to the deployer
  - Optional `PAUSER_ROLE` if we include pausability

- Behavior:

  - `mint(address to, uint256 amount)`: restricted to `MINTER_ROLE`
  - `burn(address from, uint256 amount)`: restricted to `MINTER_ROLE` (for redemptions via MasterLevr), or `burn(uint256)` for self-burn if enabled
  - Decimals should mirror the underlying token’s decimals
  - Name/Symbol: may encode the underlying identity, e.g., `<SYMBOL>W` or `w<SYMBOL>`

- Ownership and Roles:
  - The wrapper deployer retains admin rights and has `MINTER_ROLE` so they can mint at their discretion
  - `MasterLevr_v1` also has `MINTER_ROLE` to handle user mint/redeem and staking flows

## Setup and Registration (Only MasterLevr Address Known)

1. Token deployer creates the Clanker token using the Clanker SDK, ensuring `MasterLevr_v1` will be the protocol fee controller or collector for the pool (via factory/hook configuration where applicable).

2. Anyone can call `registerPool` on `MasterLevr_v1` with:

   - `underlying` address
   - `poolManager` address (v4 core)
   - `poolKeyEncoded` (ABI-encoded `PoolKey`) or enough parameters to build it
   - Optionally, wrapper metadata (name, symbol, decimals) if not inferred

3. `MasterLevr_v1` computes `PoolId`, stores config, and deploys or wires the ERC20 wrapper token for this `underlying`:
   - Grants `MINTER_ROLE` to `MasterLevr_v1` and to the deployer/admin
   - Persists `levrIdByUnderlying` and `levr[levrId]`

From this point forward, all flows are available with only the `MasterLevr_v1` address known to participants.

## Mint / Redeem and Escrow Solvency (FCFS)

- Underlying escrow is maintained entirely inside `MasterLevr_v1`.

  - User mint: user transfers `amount` of underlying to `MasterLevr_v1`; `MasterLevr_v1` mints `amount` of wrapper to the recipient and increments `underlyingEscrowed`.
  - User redeem: user submits `amount` of wrapper to `MasterLevr_v1`; `MasterLevr_v1` burns the wrapper and transfers up to `amount` of underlying out of escrow.

- Deployer mint freedom:

  - Because the deployer has `MINTER_ROLE`, they can mint wrapper beyond current escrow levels.
  - The protocol adopts First-Come-First-Served (FCFS) solvency for redemptions:
    - Redemptions are fulfilled strictly from `underlyingEscrowed`
    - If `underlyingEscrowed < redeemAmount`, the transaction reverts (or partially fulfills if explicitly supported) — there is no debt queuing.
    - Users who redeem earlier are prioritized; once escrow is depleted, later redeemers must wait for additional deposits/harvests.

- Invariants and tracking:

  - `pegRatioBps = underlyingEscrowed * 1e4 / wrapper.totalSupply()`
  - Frontends should surface solvency and peg ratio for transparency.

- Events (recommended):
  - `Minted(levrId, user, amountUnderlying, amountWrapper)`
  - `Redeemed(levrId, user, amountWrapper, amountUnderlyingPaid)`
  - `SolvencyChanged(levrId, underlyingEscrowed, wrapperSupply)`

## Staking and Rewards (Fee Distribution)

- Users can stake their wrapper tokens in `MasterLevr_v1` to earn fees harvested from the associated v4 pool.

- Reward accounting uses a global index per pool:

  - `rewardIndexX64` accumulates as `harvestAmount << 64 / stakedSupply`
  - Each user tracks `userIndexX64` at stake/unstake/claim boundaries
  - `claimable += (userStake * (rewardIndexX64 - userIndexX64)) >> 64`

- Core methods:
  - `stake(levrId, amount, to)`
  - `unstake(levrId, amount, to)`
  - `claim(levrId, to)` — pays out the fee currency accrued for that pool (typically the paired token or underlying per configuration)

## Fee Harvesting from Clanker v4

- `MasterLevr_v1` is configured as the protocol fee controller/collector for the pool.
- Anyone may call `harvest(levrId)` to collect protocol fees using v4 unlock discipline:
  - Calls `IPoolManager.unlock` with a callback that executes `collectProtocolFees(recipient=MasterLevr_v1, currency, amount)`
  - Ensures settlement nets to zero prior to re-locking; otherwise reverts per v4 constraints
  - On success, credits the harvested amounts into the pool’s reward accounting and updates `rewardIndexX64`

### Fee Attribution and Shared Currency Buckets

- Attribution model:

  - Fees are not pushed to `MasterLevr_v1`; they are pulled per-pool via `harvest(levrId)`.
  - Attribution is by call context: during `harvest(levrId)`, the contract collects only the currencies that belong to that pool’s `PoolKey` and immediately credits them to that `levrId`’s reward index.

- Shared currency buckets on the same `IPoolManager`:

  - Because `protocolFeesAccrued(currency)` is aggregated per currency (not per pool), avoid ambiguity by one of the following patterns:
    1. Pool-extension metering (recommended): a Clanker pool extension invokes `MasterLevr_v1.reportProtocolFee(poolId, amount0, amount1)` on each swap to track per-pool entitlements. On `harvest(levrId)`, allocate from the global currency bucket up to the owed entitlement for that `poolId`.
    2. Isolation: use a dedicated `IPoolManager` (or deployment) for registered pools so currency buckets are not shared with unrelated pools.
    3. Exclusivity: enforce a registry invariant that no two registered pools share the same fee currency on the same manager (e.g., `currency -> levrId` map) to prevent ambiguous attribution.

- If none of the above are enforced and multiple pools share a currency bucket, `harvest(levrId)` must conservatively cap collection to the pool’s tracked entitlement (if any); otherwise, harvesting could misattribute fees. Frontends should surface which strategy is active.

## Peg and APY Observability

- Expose read-only views per pool:

  - `getPegBps(levrId) -> uint256`: `underlyingEscrowed * 1e4 / wrapper.totalSupply()` (returns 0 if supply is 0)
  - `getRatePerSecondX64(levrId) -> uint256`: rolling rewards rate for frontends to annualize
  - Optionally provide windowed averages over the last N seconds/harvests

- APY is an off-chain presentation: `ratePerSecond * 31,536,000` as a baseline, with caveats on variable fees/TVL.

## Security, Roles, and Constraints

- Roles:

  - Wrapper `DEFAULT_ADMIN_ROLE`: deployer
  - Wrapper `MINTER_ROLE`: deployer and `MasterLevr_v1`
  - Optionally gate `registerPool` behind governance or allow anyone with guardrails (immutability of keys once set)

- Constraints:

  - `MasterLevr_v1` must have permission to collect protocol fees for a pool; otherwise harvesting is impossible
  - Address ordering and `PoolKey` correctness are enforced by v4 (`currency0 < currency1`, valid tick spacing)
  - Dynamic fee/MEV caps are respected by the underlying hook; not modified by `MasterLevr_v1` unless explicitly supported
  - FCFS solvency means no redemption guarantees if deployers over-mint — frontends and docs must warn users

- Safety:
  - Adhere to v4 unlock discipline; ensure currency settlement nets to zero before re-locking
  - Track and emit events for registration, mint, redeem, stake, unstake, claim, harvest
  - Consider reentrancy guards around state mutations and external transfers

## Minimal External Interface (Indicative)

```solidity
// Registration
function registerPool(
    address underlying,
    address poolManager,
    bytes calldata poolKeyEncoded,
    string calldata name,
    string calldata symbol
) external returns (uint256 levrId, address wrapper);

// Mint/Redeem (user flows)
function mint(uint256 levrId, uint256 amountUnderlying, address to) external;
function redeem(uint256 levrId, uint256 amountWrapper, address to) external;

// Staking
function stake(uint256 levrId, uint256 amount, address to) external;
function unstake(uint256 levrId, uint256 amount, address to) external;
function claim(uint256 levrId, address to) external;

// Fees
function harvest(uint256 levrId) external;

// Views
function getPegBps(uint256 levrId) external view returns (uint256);
function getRatePerSecondX64(uint256 levrId) external view returns (uint256);
```

## Implementation Notes

- Wrapper deployment can be minimal proxies (clones) pointing to a single ERC20 implementation to keep gas low while maintaining per-pool metadata and role configuration.
- Wrapper decimals should mirror the underlying token to preserve 1:1 unit expectations.
- Peg ratio and solvency should be surfaced in UIs prominently, with FCFS caveats.
- If partial redemption is supported, define and emit `Redeemed` with the actual fulfilled amount; otherwise revert on insufficient escrow.

## Clanker v4 Integration Reminders

- `MasterLevr_v1` should be set as protocol fee controller (or have the appropriate permissions) during Clanker SDK deployment.
- Use `IPoolManager.collectProtocolFees` inside an `unlock` flow to harvest and credit rewards.
- Optional reads for UI/analytics:
  - `IClankerHookDynamicFee.poolConfigVars(poolId)` / `poolFeeVars(poolId)`
  - `IClankerHookV2.mevModuleOperational(poolId)` / `mevModuleEnabled(poolId)`
  - `IPoolManager.protocolFeesAccrued(currency)` / `protocolFeeController()`

---

This rule is normative. Contract implementations and SDK integrations should align with the above semantics. Any divergence should update this document first.

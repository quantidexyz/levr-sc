---
alwaysApply: false
---
# ⚠️ CRITICAL: RULE MAINTENANCE ⚠️

**THIS RULE MUST BE KEPT UP TO DATE WITH THE CODEBASE**

When making ANY architectural changes, contract modifications, or adding new features:

1. **IMMEDIATELY update this rule** to reflect the changes
2. Update the architecture diagrams
3. Update contract descriptions and functions
4. Update code patterns and examples
5. Add any new design decisions or rationale

**Outdated rules lead to incorrect agent behavior and hallucinated code.**

---

## Levr Protocol v1 — Architecture Guide

Source-of-truth for Levr Protocol v1 contracts. Modular system: Factory deploys per-project Treasury, Governor, Staking, and StakedToken.

**✨ Full ERC2771 meta-transaction support** - Users can interact gaslessly via trusted forwarder.

### Architecture

```
LevrFactory_v1 (deploys ERC2771Forwarder in constructor)
  ↓ prepareForDeployment() → (treasury, staking)
  ↓ register(clankerToken) → Project{treasury, governor, staking, stakedToken}

All contracts extend ERC2771ContextBase → support meta-transactions
```

## Contracts

### LevrFactory_v1 (Singleton)

**Role**: Registry and deployment coordinator

**Extends**: `ERC2771Context` (supports meta-transactions)

**Constructor**: `constructor(FactoryConfig, owner, trustedForwarder)`

- Accepts a pre-deployed `ERC2771Forwarder` address
- Factory itself supports meta-transactions for `prepareForDeployment()` and `register()`
- All contracts deployed by factory trust the same forwarder

**Functions**:

- `prepareForDeployment()` → Deploy treasury & staking, return addresses
  - Anyone can call; stores `deployer → PreparedContracts`
  - Uses `_msgSender()` for meta-tx support
  - Call BEFORE Clanker deployment to get addresses
  - Passes `trustedForwarder` to deployed contracts
- `register(clankerToken)` → Complete setup, return `Project` struct
  - Only `clankerToken.tokenAdmin()` can call
  - Uses `_msgSender()` for meta-tx support
  - Auto-uses prepared contracts from caller (or deploys new)
  - Returns `Project{treasury, governor, staking, stakedToken}`
- `getProjectContracts(clankerToken)` → Query registered project
- `trustedForwarder()` → Returns the deployed forwarder address
- `executeTransaction(target, data)` → Execute arbitrary call from factory
  - Public function, anyone can call
  - Useful for chaining transactions in forwarder multicall
  - Executes call FROM the factory contract
  - Returns `(success, returnData)`

**Security**: Only deployer can use their prepared contracts; only tokenAdmin can register

**Meta-Transactions**: Factory and all deployed contracts support gasless transactions via the forwarder

---

### ERC2771ContextBase (Base Contract)

**Role**: Base contract for meta-transaction support

**Location**: `src/base/ERC2771ContextBase.sol`

**Purpose**:

- Eliminates code duplication across contracts
- Provides centralized ERC2771Context overrides
- Resolves multiple inheritance (ReentrancyGuard + ERC2771Context)

**Usage**: All user-facing contracts extend this base:

```solidity
contract LevrStaking_v1 is ILevrStaking_v1, IERC1363Receiver, ReentrancyGuard, ERC2771ContextBase {
  constructor(address trustedForwarder) ERC2771ContextBase(trustedForwarder) {}

  function stake(uint256 amount) external {
    address staker = _msgSender(); // Extracts real sender from meta-tx
    // ...
  }
}
```

**Key Pattern**: Use `_msgSender()` instead of `msg.sender` everywhere to support meta-transactions

---

### LevrTreasury_v1

**Role**: Asset custody (NOT Ownable - governor controls)

**Extends**: `ERC2771ContextBase` (supports meta-transactions)

**Constructor**: `constructor(address factory_, address trustedForwarder)`

**Functions**:

- `transfer(to, amount)` → Governor-authorized transfer
- `applyBoost(amount)` → Move to staking, accrue rewards
- `initialize(governor, underlying)` → One-time init by factory

**Access**: `onlyGovernor` modifier (uses `_msgSender()` for meta-tx support)

**Meta-Transaction Support**: Governor calls can be relayed via forwarder

---

### LevrGovernor_v1

**Role**: Governance and proposals

**Extends**: `ERC2771ContextBase` (supports meta-transactions)

**Constructor**: `constructor(address factory_, address treasury_, address stakedToken_, address trustedForwarder)`

**Functions**:

- `proposeTransfer(receiver, amount, reason)` → Custom amounts (gasless via meta-tx)
- `proposeBoost(amount)` → Custom amounts (gasless via meta-tx)
- `execute(proposalId)` → Anyone can execute
- `getProposal(proposalId)` → View proposal
- `canSubmit(proposer)` → Check eligibility

**Validation**: Min staked balance, rolling windows, deadlines

**Meta-Transaction Support**: Users can submit proposals without holding ETH

---

### LevrStaking_v1

**Role**: Stake escrow, multi-token rewards

**Extends**: `ERC2771ContextBase` (supports meta-transactions)

**Constructor**: `constructor(address trustedForwarder)`

**Functions**:

- `stake(amount)`, `unstake(amount, to)` → Mint/burn stakedToken 1:1 (gasless via meta-tx)
- `accrueRewards(token, amount)` → Delta-based accrual
- `accrueFromTreasury(token, amount, pull)` → Boost from treasury
- `claimRewards(tokens[], to)` → Multi-token claim (gasless via meta-tx)
- `initialize(underlying, stakedToken, treasury)` → One-time init by factory

**Reward Paths**:

1. ERC-1363 auto-credit (`onTransferReceived`)
2. Governor boost → `treasury.applyBoost` → `staking.accrueFromTreasury`
3. Manual `accrueRewards`

**Safety**: Reserve tracking, liquidity checks, streaming windows

**Meta-Transaction Support**: Users can stake/unstake/claim without holding ETH

---

### LevrStakedToken_v1

**Role**: 1:1 staked representation, governance weight

**Access**: Only staking can mint/burn

## Deployment Flow

### Complete Workflow

```solidity
// 1. Prepare (get addresses before Clanker exists)
(address treasury, address staking) = factory.prepareForDeployment();

// 2. Deploy Clanker token
// - Set treasury as airdrop recipient → receives initial allocation
// - Set staking as LP fee recipient → receives ongoing trading fees

// 3. Register (as tokenAdmin)
ILevrFactory_v1.Project memory project = factory.register(clankerToken);
// Access: project.treasury, project.governor, project.staking, project.stakedToken
```

### Initialization Sequence

1. Treasury & Staking deployed via `prepareForDeployment()`
2. Clanker token deployed (uses treasury/staking addresses)
3. `register()` deploys governor & stakedToken, initializes all contracts
4. Governor set as treasury controller, staking linked to treasury

---

## Core Flows

### Staking

```
User stakes → Staking escrows underlying, mints stakedToken 1:1
User unstakes → Staking burns stakedToken, returns underlying
```

### Rewards

```
Clanker LP fees → Staking (auto-accrues via ERC-1363)
Clanker airdrops → Treasury
Governor proposes boost → Treasury.applyBoost(amount)
Treasury → Staking.accrueFromTreasury (measures delta, credits immediately)
Users claim → Multi-token claim with reserve checks
```

### Governance

```
User (with minWTokenToSubmit) → proposeTransfer or proposeBoost (custom amounts)
Validates: rolling windows, deadlines
Execute → Treasury performs action (transfer or boost)
```

## Data Structures

```solidity
struct Project {
  address treasury;
  address governor;
  address staking;
  address stakedToken;
}

struct PreparedContracts {
  address treasury;
  address staking;
}
```

---

## Security

### Access Controls

| Function                         | Who Can Call                           |
| -------------------------------- | -------------------------------------- |
| `factory.prepareForDeployment()` | Anyone (tracked by deployer)           |
| `factory.register()`             | Only `clankerToken.tokenAdmin()`       |
| `treasury.transfer/applyBoost()` | Only governor                          |
| `governor.propose*()`            | Anyone with `minWTokenToSubmit` staked |
| `staking.stake/unstake/claim()`  | Anyone                                 |
| `stakedToken.mint/burn()`        | Only staking                           |

### Protections

- **Reentrancy**: Guards on all treasury/staking external functions
- **Double Registration**: Prevented via `ALREADY_REGISTERED` check
- **Front-running**: Only deployer can use their prepared contracts
- **Reward Safety**: Reserve tracking prevents overdraw
- **No Owner on Treasury**: Governor controls all operations

### Invariants

- StakedToken supply == total underlying staked
- Reward reserves >= pending claims
- One project per clankerToken
- Prepared contracts only usable by deployer

## Configuration

### Factory Config

- `protocolFeeBps` — Protocol fee (basis points)
- `submissionDeadlineSeconds` — Proposal deadline (7 days default)
- `streamWindowSeconds` — Reward streaming (3 days default)
- `maxSubmissionPerType` — Rate limit per proposal type (0 = unlimited)
- `minWTokenToSubmit` — Min staked tokens to propose
- `protocolTreasury` — Protocol treasury address

**Note**: `trustedForwarder` is NOT in config - automatically deployed in constructor

### Proposal Amounts

**Custom amounts**: No tiers - proposers specify exact amounts for transfers and boosts

### Meta-Transaction Forwarder

- **Implementation**: `LevrForwarder_v1` (extends OpenZeppelin's `ERC2771Forwarder`)
- **Deployment**: Must be deployed BEFORE factory
- **Name**: "LevrForwarder_v1"
- **Features**:
  - Standard ERC2771 meta-transaction support (via `execute()`)
  - **Multicall support** (via `executeMulticall()`) - execute multiple calls in ONE transaction
  - Signature verification and nonce management
- **Access**: `factory.trustedForwarder()` returns address
- **Immutable**: Cannot be changed after factory deployment
- **Shared**: All projects from same factory use same forwarder
- **Factory Support**: Factory itself supports meta-tx for `prepareForDeployment()` and `register()`

---

## Code Patterns

### Registration

```solidity
// Deploy forwarder FIRST
LevrForwarder_v1 forwarder = new LevrForwarder_v1("LevrForwarder_v1");

// Factory setup with forwarder
LevrFactory_v1 factory = new LevrFactory_v1(config, owner, address(forwarder));

// Prepare before Clanker
(address treas, address stak) = factory.prepareForDeployment();

// Deploy Clanker (use treas & stak addresses)

// Register
ILevrFactory_v1.Project memory p = factory.register(clankerToken);
```

### Accessing Components

```solidity
ILevrFactory_v1.Project memory proj = factory.getProjectContracts(token);

LevrTreasury_v1(payable(proj.treasury));
LevrGovernor_v1(proj.governor);
LevrStaking_v1(proj.staking);
LevrStakedToken_v1(proj.stakedToken);
```

### Using Meta-Transactions

```solidity
// Users sign transactions, relayers execute
LevrForwarder_v1 forwarder = LevrForwarder_v1(factory.trustedForwarder());

// Example: Gasless stake
ERC2771Forwarder.ForwardRequestData memory request = ERC2771Forwarder.ForwardRequestData({
  from: user,
  to: address(staking),
  value: 0,
  gas: 300000,
  deadline: uint48(block.timestamp + 1 hours),
  data: abi.encodeWithSelector(LevrStaking_v1.stake.selector, amount),
  signature: userSignature
});

// Relayer executes (pays gas)
forwarder.execute(request);
```

### Chaining Transactions with Multicall

`LevrForwarder_v1.executeMulticall()` enables complex multi-step operations in ONE transaction:

```solidity
// Example: Complete project deployment - prepare + register in ONE transaction!
ILevrForwarder_v1.SingleCall[] memory calls = new ILevrForwarder_v1.SingleCall[](2);

// Call 1: Prepare deployment
calls[0] = ILevrForwarder_v1.SingleCall({
  target: address(factory),
  allowFailure: false,
  callData: abi.encodeWithSelector(LevrFactory_v1.prepareForDeployment.selector)
});

// Call 2: Register token
calls[1] = ILevrForwarder_v1.SingleCall({
  target: address(factory),
  allowFailure: false,
  callData: abi.encodeWithSelector(LevrFactory_v1.register.selector, clankerToken)
});

// Execute as user (multicall extracts user from msg.sender and appends to each call)
forwarder.executeMulticall(calls);
```

**Key Benefit**: User deploys entire project without paying gas - just signs off-chain!

### Creating New Contracts

**ALWAYS extend ERC2771ContextBase for user-facing contracts:**

```solidity
import {ERC2771ContextBase} from './base/ERC2771ContextBase.sol';

contract MyContract is ERC2771ContextBase {
  constructor(address trustedForwarder) ERC2771ContextBase(trustedForwarder) {}

  function myFunction() external {
    address realSender = _msgSender(); // NOT msg.sender!
    // ...
  }
}
```

**NEVER use `msg.sender` directly - always use `_msgSender()`**

---

## Testing

**Must Cover**:

- Security: Access controls, deployer tracking, meta-tx signature verification
- Flows: Stake → Boost → Claim → Unstake (both direct and meta-tx)
- Governance: Proposals, custom amounts, execution, deadlines (gasless proposals)
- Rewards: Multi-token, reserves, streaming
- Meta-Transactions: Stake, unstake, claim, propose via forwarder
- Edge cases: Zero amounts, double registration, unauthorized calls
- Forwarder: `isTrustedForwarder()`, signature verification, nonce management

**Test Files**:

- `test/e2e/LevrV1.MetaTx.t.sol` - Meta-transaction tests
  - `test_MetaTx_Stake` - Gasless staking
  - `test_MetaTx_ProposeTransfer` - Gasless proposals
  - `test_MetaTx_Unstake` - Gasless unstaking
  - `test_MetaTx_Multicall_CompleteDeployment` - Full deployment via multicall (prepare → register)
- `test/unit/LevrStakingV1.t.sol` - Pass `address(0)` for forwarder in unit tests if not testing meta-tx

**Test Coverage for executeTransaction**:

- Test basic call execution via factory
- Test with forwarder multicall chaining (see `test_MetaTx_Multicall_CompleteDeployment`)
- Test return values (success, returnData)
- Test reentrancy protection

## Key Design Decisions

### Why No CREATE2 / Deterministic Addresses?

- **prepareForDeployment**: Simple `new Contract()` - no salting
- **register**: Deploys governor/stakedToken without salts
- **Reason**: Addresses don't need prediction - treasury/staking exist before Clanker

### Why No Ownable on Treasury?

- **Governor controls all operations** via `onlyGovernor` modifier
- **Register is gated** by `tokenAdmin` check - no front-running
- **Simpler, cleaner** - one less security layer to manage

### Why Auto-Lookup of Prepared Contracts?

- **Mapping tracks deployer** → `PreparedContracts{treasury, staking}`
- **register() auto-uses** prepared contracts from `msg.sender`
- **Security**: Only deployer can use their contracts (no parameters to hijack)

### Why Return Project Struct?

- **Cleaner API**: One struct vs four separate addresses
- **Type safety**: All addresses grouped logically
- **Easier usage**: `proj.treasury` vs destructuring

### Why Forwarder Deployed Before Factory?

- **Factory Meta-TX Support**: Factory needs to extend ERC2771Context to support meta-tx on `prepareForDeployment()` and `register()`
- **Constructor Limitation**: Can't deploy forwarder in constructor if factory extends ERC2771Context
- **Security**: Immutable, can't be changed after deployment
- **Consistency**: All projects from same factory share same forwarder
- **Standard**: Uses OpenZeppelin's battle-tested `ERC2771Forwarder`
- **Factory Functions**: `prepareForDeployment()` and `register()` use `_msgSender()` for meta-tx support

### Why ERC2771ContextBase Base Contract?

- **DRY Principle**: Eliminates ~135 lines of duplicated override code
- **Maintainability**: One place to update ERC2771 logic
- **Multiple Inheritance**: Cleanly resolves ReentrancyGuard + ERC2771Context diamond pattern
- **Type Safety**: Enforces consistent meta-transaction handling

**Note**: Factory extends `ERC2771Context` directly and implements its own overrides because Solidity's override specification doesn't allow inheriting through abstract base contracts in complex diamond patterns.

### Why executeTransaction on Factory?

- **Multicall Composition**: Enables complex transaction chains via forwarder
- **Flexible Routing**: Factory can execute arbitrary calls in multicall sequences
- **Gas Efficiency**: Single meta-tx signature covers multiple operations
- **Public Access**: No restrictions - useful for composability
- **Reentrancy Protected**: Uses ReentrancyGuard for safety

---

## Changes from Previous Versions

### Removed

- ❌ `registerDryRun()` - unreliable prediction
- ❌ CREATE2 salting - not needed
- ❌ Treasury `Ownable` - redundant
- ❌ Multiple return values - now returns struct
- ❌ Treasury/staking params in register - auto-lookup
- ❌ Tier system - replaced with custom amounts

### Added

- ✅ `prepareForDeployment()` - pre-deploy infrastructure
- ✅ Deployer tracking - security via mapping
- ✅ `Project` struct returns - cleaner API
- ✅ Auto-lookup prepared contracts
- ✅ Treasury receives airdrops, Staking receives fees (split roles)
- ✅ Custom proposal amounts - no tier restrictions
- ✅ **ERC2771 meta-transaction support** - gasless transactions via forwarder
- ✅ **ERC2771ContextBase** - base contract eliminates duplication
- ✅ **Auto-deployed forwarder** - no manual configuration needed
- ✅ **executeTransaction** - factory function for multicall composition

---

## Critical Patterns and Anti-Patterns

### ✅ DO

- **ALWAYS** use `_msgSender()` instead of `msg.sender` in user-facing contracts
- **ALWAYS** extend `ERC2771ContextBase` for new contracts that need meta-tx support (except factory)
- **ALWAYS** deploy forwarder BEFORE factory
- **ALWAYS** pass `trustedForwarder` to contract constructors
- **ALWAYS** update this rule when making architectural changes
- **CONSIDER** using `factory.executeTransaction()` for complex multicall sequences

### ❌ DON'T

- **NEVER** use `msg.sender` directly in contracts that extend ERC2771ContextBase or ERC2771Context
- **NEVER** create custom forwarders - use OpenZeppelin's `ERC2771Forwarder`
- **NEVER** manually override `_msgSender()/_msgData()/_contextSuffixLength()` - use base contract (except factory)
- **NEVER** forget to pass `address(0)` for forwarder in unit tests if not testing meta-tx
- **NEVER** let this rule become outdated
- **NEVER** deploy factory before deploying forwarder
- **AVOID** using `executeTransaction` for operations requiring specific caller identity

---

## File Structure

```
src/
  base/
    ERC2771ContextBase.sol         # Base contract for meta-tx support
  LevrFactory_v1.sol                # Factory (extends ERC2771Context directly)
  LevrTreasury_v1.sol               # Extends ERC2771ContextBase
  LevrGovernor_v1.sol               # Extends ERC2771ContextBase
  LevrStaking_v1.sol                # Extends ERC2771ContextBase
  LevrStakedToken_v1.sol            # No meta-tx (not user-facing)
  interfaces/
    ILevrFactory_v1.sol             # Factory interface
    ILevrGovernor_v1.sol            # Governor interface
    ILevrStaking_v1.sol             # Staking interface
    ILevrTreasury_v1.sol            # Treasury interface
    ILevrStakedToken_v1.sol         # StakedToken interface

test/
  e2e/
    LevrV1.MetaTx.t.sol             # Meta-transaction tests
    LevrV1.Governance.t.sol
    LevrV1.Registration.t.sol
    LevrV1.Treasury.t.sol
  unit/
    LevrFactoryV1.*.t.sol
    LevrGovernorV1.t.sol
    LevrStakingV1.t.sol
    LevrTreasuryV1.t.sol
    LevrStakedTokenV1.t.sol
```

---

**This rule is normative. All contract code must align with these specifications.**

**⚠️ REMEMBER: Update this rule immediately when making any changes! ⚠️**

---
alwaysApply: true
---

### Clanker integration rule

This rule documents how Clanker pools/tokens are launched, how fees are produced and distributed via Uniswap v4 hooks, and the mechanics your contracts can levrage to wrap tokens, route fees, and perform actions like buybacks.

### Scope and goals

- Clarify pool/token launch paths and participants
- Explain fee surfaces: LP fees, dynamic fees, MEV module fees, and protocol fees
- Identify the extension points you can hook into for custom logic (e.g., buybacks)
- Outline a practical wrapping approach: lock original token → mint 1:1 synthetic → interact

### Key components (by interface)

- `IClanker`: main Clanker deployment surface (aka Factory). Deploys tokens and pools via `deployTokenZeroSupply(TokenConfig)` and `deployToken(DeploymentConfig)`; emits `TokenCreated` with `PoolId`, hook, locker, MEV module, and metadata. Also coordinates extensions.
- `IPoolManager`: v4 core manager for pools, swaps, liquidity, donations, fee controls (`setProtocolFee`, `collectProtocolFees`), transient accounting via `unlock` flow.
- `IHooks`: lifecycle callbacks around initialize/add/remove liquidity, swap, donate.
- `IClankerHook`/`IClankerHookV2`: Clanker pool factory/manager hook. Handles pool initialization, optional MEV module enablement, per-pool extensions, and exposes fee/operability controls (`mevModuleSetFee`, `mevModuleOperational`, caps via `MAX_LP_FEE`/`MAX_MEV_LP_FEE`). Emits pool creation events.
- `IClankerHookDynamicFee`: per-pool dynamic fee variables and config (base fee, max LP fee, decay, reference tick periods, etc.).
- `IClankerHookV2PoolExtension`: per-pool extension interface invoked by the hook to run custom logic on initialization phases and on each swap (`afterSwap`).
- `IClankerPoolExtensionAllowlist`: gate which extensions can be attached for factory-created pools.
- `IClankerExtension`/`IClankerAirdrop`: extension base and airdrop extension surface to receive and distribute extension allocations on deploy.
- `IPositionManager`: convenience batching for modifying liquidity positions; not required for swap-only flows.
- `IProtocolFees`: protocol fee controller surface and accounting on `IPoolManager`.
- Supporting types: `PoolKey`, `PoolId`, `BalanceDelta`, `Currency`, and `Actions` constants for higher-level routers.

### High-level launch and operation flow

```mermaid
flowchart TD
  subgraph Launch
    A[Token_Deployer] -->|calls| H[Clanker_Hook/Factory]
    H -->|"initializePool (factory)"| P1[PoolKey_created]
    H -->|"initializePoolOpen (open route)"| P1
    P1 -->|Initialize_event| PM[IPoolManager]
    H -->|optional:_initializeMevModule| M[MEV_Module]
    H -->|optional:_register| X[Pool_Extension]
  end

  subgraph Swap_Cycle
    T[Trader] -->|swap| PM
    PM -->|before/after_hooks| H
    H -->|beforeSwap/afterSwap| X
    H -->|dynamic_fee_update| DF[Dynamic_Fee_Vars]
  end

  subgraph Fees
    PM -->|LP_fee_accrual| LP[Liquidity_Providers]
    PM -->|protocol_fee| PF[Protocol_Fee_Bucket]
    M -->|may_set_fee_override| PM
    X -->|"optional actions (e.g. buyback)"| BB[Buybacks]
  end

  PF -->|collectProtocolFees| TRE[Treasury]
```

### How a Clanker token/pool is launched

- Paths:
  - Factory deploy path: `IClanker.deployToken(DeploymentConfig)` orchestrates token creation and pool initialization using the configured hook, paired token, tick math, locker, MEV module, and extensions. Emits `TokenCreated` with `PoolId` and configuration addresses.
  - Hook initialize path (internal to factory or open): `IClankerHook.initializePool(clanker, pairedToken, tickIfToken0IsClanker, tickSpacing, locker, mevModule, poolData)`
    - Emits `PoolCreatedFactory` with `locker` and `mevModule` addresses.
    - Allows later `initializeMevModule(...)` to turn on MEV logic; pool extensions can be restricted to factory pools.
  - Open path: `IClankerHook.initializePoolOpen(...)`
    - Emits `PoolCreatedOpen`. No factory-managed locker/MEV by default.
- Initial price/tick are set via `IPoolManager.initialize(PoolKey, sqrtPriceX96)`; the hook’s `beforeInitialize/afterInitialize` run around this call.
- Constraints and guards commonly enforced by the hook:
  - `ETH/Native` pools may be disallowed (`ETHPoolNotAllowed`).
  - Ordering: currency0 < currency1 (v4 invariant), validated by `IPoolManager`.
  - `WethCannotBeClanker` and `UnsupportedInitializePath` may apply to specific deployments.
  - Creation time windows and MEV enablement checks (`PastCreationTimestamp`, `MevModuleEnabled`).

### Fee mechanics and distribution surfaces

- LP swap fees
  - Pools can use static fees or dynamic fees.
  - Dynamic fees source of truth: `IClankerHookDynamicFee.poolConfigVars(poolId)` and `poolFeeVars(poolId)` expose base fee, max LP fee, decay, reference/reset tick data, and applied volatility reference values.
  - The hook can influence fees during `beforeSwap` by returning a fee override if allowed by pool config and caps; v4 reads this and applies if the 23rd bit flag and cap conditions are met.
  - Global caps exposed by `IClankerHookV2.MAX_LP_FEE()` and `MAX_MEV_LP_FEE()`; validations may revert on excess.
- Protocol fees
  - Managed at `IPoolManager` via `setProtocolFee(PoolKey, uint24)` and `collectProtocolFees(recipient, Currency, amount)`.
  - Accrual tracked per currency in `protocolFeesAccrued(Currency)`; controller settable via `setProtocolFeeController`.
  - When collected, fees transfer to a recipient treasury; collection requires the manager to be locked (standard v4 unlock discipline applies).
- MEV module fees
  - When enabled, `mevModuleSetFee(PoolKey, uint24)` may adjust LP fee within allowed bounds for MEV-aware capture.
  - Operability gated by `mevModuleOperational(poolId)` and `mevModuleEnabled(poolId)`.
- Donations
  - Anyone can `donate(PoolKey, amount0, amount1)` to in-range LPs at `slot0.tick`. This can be used to push value to LPs (and indirectly alter fee growth accounting); beware JIT-liquidity side effects.

### Pool extensions (custom logic on swaps)

- `IClankerHookV2PoolExtension` receives lifecycle callbacks:
  - `initializePreLockerSetup(...)` and `initializePostLockerSetup(...)` during pool bring-up.
  - `afterSwap(...)` on every swap with the pool’s `BalanceDelta` and swap params; ideal place to run post-swap actions.
- Extensions can be gated by `IClankerPoolExtensionAllowlist`; factory-only pools may be permitted to attach extensions (`OnlyFactoryPoolsCanHaveExtensions`).
- Failures can be surfaced via events: `PoolExtensionSuccess/Failed` with `PoolId` and swap params.

### What you can levrage for wrapping and buybacks

1. 1:1 wrapping flow

   - Deploy a `Locker` contract that escrows the original Clanker-launched token.
   - On deposit, mint a 1:1 synthetic (your ERC20 or ERC6909) to the user.
   - On redemption, burn synthetic and release the original token.
   - Maintain hard peg via strict accounting and reentrancy/approval controls.

2. Trading and integrations for the wrapped token

   - List either the original or the wrapped token in the Clanker pool. If the wrapped token trades, ensure `PoolKey` uses correct `currency0/currency1` order and initialize price accordingly.
   - Use `IPositionManager` or custom router with `IPoolManager.swap` and `modifyLiquidity` for LP operations.

3. Fee capture → buybacks

   - Protocol fee path: set yourself (or a controller contract) as protocol fee controller for the relevant pools; periodically call `collectProtocolFees` into your treasury, then execute buybacks.
   - Extension path: implement a pool extension (`IClankerHookV2PoolExtension`) to run buyback logic in `afterSwap` using part of the swap delta or pre-configured reserves. Keep actions minimal to avoid excessive gas and revert risk; use emitted `PoolExtensionSuccess/Failed` for monitoring.
   - MEV path: where safe, use `mevModuleSetFee` within caps to redirect more margin to your preferred capture route (subject to governance/allowlists).
   - Donation path: schedule `donate` to reward in-range LPs or to rebalance incentives around re-pegs or liquidity targets.

4. Accounting and safety
   - Respect v4 unlock discipline: complex sequences require `IPoolManager.unlock` with your `unlockCallback` batching state changes; otherwise calls will revert (`ManagerLocked`, `AlreadyUnlocked`).
   - Ensure currency settlement is netted to zero before re-locking; otherwise `CurrencyNotSettled` can revert.
   - Guard caps and roles: dynamic fee bounds, `OnlyFactory`, `OnlyHook`, `OnlyThis`, and admin allowlists.

### Useful on-chain reads for strategy logic

- Dynamic fee state: `IClankerHookDynamicFee.poolConfigVars(poolId)`, `poolFeeVars(poolId)`
- MEV status: `IClankerHookV2.mevModuleOperational(poolId)`, `mevModuleEnabled(poolId)`, creation time via `poolCreationTimestamp(poolId)` and `MAX_MEV_MODULE_DELAY()`
- Protocol fees: `IPoolManager.protocolFeesAccrued(currency)`, `protocolFeeController()`
- Pool identity and events: `IClankerHook.PoolCreatedOpen/Factory`, `MevModuleSetFee`, `MevModuleDisabled`

### Recommended integration patterns

- Use a factory to deploy wrapped-token vaults with immutable references to the underlying token and its Clanker pool `PoolKey`/`PoolId`.
- If using extensions, pre-register your `PoolExtension` via `IClankerPoolExtensionAllowlist` and supply its address in `PoolInitializationData` when supported.
- For buybacks:
  - Simple: periodically harvest with an offchain keeper calling `collectProtocolFees` and performing swaps.
  - Reactive: minimal `afterSwap` logic to accrue/track balances; perform actual buyback via a separate, rate-limited function to control gas and slippage.
- Avoid coupling extension logic to price-sensitive operations; prefer posting intents and executing through a deterministic router function.

### Constraints and caveats

- Address ordering (`currency0 < currency1`) and tick spacing bounds are enforced by `IPoolManager` (`TickSpacingTooSmall/TooLarge`).
- Setting excessive fees will revert (`ProtocolFeeTooLarge`, dynamic fee max checks, `MAX_LP_FEE`, `MAX_MEV_LP_FEE`).
- Some deployments disallow native-asset pools or certain clanker pairings (`ETHPoolNotAllowed`, `WethCannotBeClanker`).
- Donations can be gamed by JIT LPs; use with caution around incentive events.

### Minimal checklist for your wrapper

- Lock contract for original token with 1:1 mint/burn synthetic
- Clanker pool selection and initialization (factory or open)
- Optional pool extension registered and allowlisted
- Protocol fee controller set; harvest to treasury
- Buyback executor with safety rails (rate limits, slippage limits, pausable)
- Monitoring of dynamic fee state and MEV module operability

### Token metadata (IClanker)

- IClanker exposes on-chain token metadata via `TokenConfig` during deploy:
  - `tokenAdmin`, `name`, `symbol`, `salt`, `image` (string/URI), `metadata` (string/URI/JSON), `context` (string), `originatingChainId`.
- Deploy paths:
  - `deployTokenZeroSupply(TokenConfig)`
  - `deployToken(DeploymentConfig)` where `DeploymentConfig.tokenConfig` := `TokenConfig` (payable; may allocate per-extension via `ExtensionConfig.msgValue`).
- Events:
  - `TokenCreated` includes: `tokenAddress`, `tokenAdmin`, `tokenImage`, `tokenName`, `tokenSymbol`, `tokenMetadata`, `tokenContext`, `poolHook`, `PoolId`, `pairedToken`, `locker`, `mevModule`, `extensions`.
- UI/indexers:
  - UIs read name/symbol/decimals on-chain and may read `image/metadata/context`, but many still prefer curated token lists; listing/logo may require submitting to their registry even if events exist on-chain.

---
description: Lever protocol construction, fork-testing with Clanker v4, and Lever Factory deployment script
alwaysApply: false
---

### Lever protocol — Construction, testing on fork, and factory deployment

This rule specifies how we structure the Lever contracts, how we test them against a live Clanker v4 deployment using forked chains, and how we build a robust deployment script for the Lever Factory. `Locker` + `WrappedToken` are core components of Lever.

See also: `asset_flows.mdc` and `clanker.mdc` for fee surfaces, `IPoolManager` unlock discipline, and extension semantics.

### Goals

- Construct a clear, modular Lever stack with explicit roles and safety rails
- Validate end-to-end behavior on a fork where Clanker contracts already exist
- Provide a deterministic deployment script for the Lever Factory and auxiliaries

### High-level architecture

```mermaid
flowchart TD
  subgraph Lever_Core
    L[Lever]:::box --> LT[LeverTreasury]
    LT --> SR[StakerRewards]
  end

  subgraph Fee_Plumbing
    FC[LeverFeeController]:::box -->|setProtocolFeeController| PM[IPoolManager]
    PH[ProtocolFeeHarvester]:::box -->|unlock->collectProtocolFees| LT
  end

  subgraph Wrapping (Core)
    K[Locker]:::box --> WT[WrappedToken]
  end

  subgraph Clanker_v4
    PM --> HK[IClankerHook]
    HK -->|optional| X[PoolExtension]
  end

  classDef box fill:#0b7285,stroke:#0b7285,color:#fff;
```

### Contract construction blueprint

- **Core components**

  - **Lever**: entrypoint for protocol actions and governance-controlled parameters.
  - **LeverTreasury**: receives harvested protocol fees and routes funds per policy (to `StakerRewards`, treasury wallet, and optional buyback executor). Must be pausable.
  - **StakerRewards**: pull-based rewards distribution to stakers. Should support funding in multiple currencies.

- **Fee plumbing**

  - **LeverFeeController**: owns `IPoolManager.setProtocolFeeController` and per-pool `setProtocolFee(PoolKey, uint24)` rights. Enforces caps, allowlists, and rate limits.
  - **ProtocolFeeHarvester**: keeper-called. Uses `IPoolManager.unlock` to batch `collectProtocolFees(recipient=LeverTreasury, currency, amount)` while ensuring net settlement == 0 before re-lock.

- **Wrapping (core)**

  - **Locker**: escrows the original token; mints/burns `WrappedToken` 1:1 on deposit/withdraw.
  - **WrappedToken**: ERC20/ERC6909 synthetic pegged 1:1 to escrowed original. Supports an opt‑in governance "full‑control mode" with concurrent authorities (see below). Disabled by default.

- **Access & safety**
  - Roles: `OWNER`/`GOVERNANCE` for parameterization; `KEEPER` for harvester; `PAUSER` for emergencies.
  - Guards: cap protocol fees, allowlist pools, enforce unlock discipline, and rate-limit buybacks.

### Testing strategy — forked chain with Clanker deployed

We validate Lever end-to-end by forking a network where Clanker v4 exists, wiring Lever components to the live `IPoolManager`, and executing the full operational flow.

- **Prerequisites**

  - Set `MAINNET_RPC_URL` (or target network RPC) in the environment.
  - Known addresses for `IPoolManager` and, if used, `IClankerHook` (configurable via env to remain chain-agnostic).
  - Optionally, known pools and tokens for which to set protocol fees; otherwise, tests can initialize a fresh pool via the open/factory path on fork if permissible.

- **Foundry configuration**

  - Use `foundry.toml` RPC endpoints or pass `--fork-url $MAINNET_RPC_URL`.
  - Prefer deterministic test seeds and labels for readability.

- **Test scenarios**

  1. Construction
     - Deploy `Lever`, `LeverTreasury`, `StakerRewards`, `LeverFeeController`, `ProtocolFeeHarvester`.
     - Wire roles: set treasury recipients, keeper, pauser, and governance.
  2. Controller setup
     - `IPoolManager.setProtocolFeeController(LeverFeeController)`.
     - For a target `PoolKey`, call `setProtocolFee(PoolKey, fee)` within allowed bounds; assert via on-chain reads.
  3. Wrapping path (core)
     - Deposit into `Locker` → assert `WrappedToken` 1:1 mint; redeem path burns and releases original.
  4. Liquidity and swaps (if seeding a new pool on fork)
     - Initialize pair (respect `currency0 < currency1`), seed minimal liquidity, execute representative swaps.
  5. Fee accrual and harvest
     - After swaps, read `IPoolManager.protocolFeesAccrued(Currency)` > 0.
     - Call `ProtocolFeeHarvester.harvest(currencies[])` → ensure unlock → `collectProtocolFees` → funds arrive in `LeverTreasury`.
  6. Distribution and policy
     - Treasury splits to `StakerRewards` and treasury wallet per configured ratios.
     - Optional: run a small buyback through a deterministic router with tight slippage, off-hook.
  7. Safety rails
     - Pausing treasury/buyback halts executions but allows fees to keep accruing at manager.
     - Attempt out-of-range fees → expect revert by caps; attempt extension-only actions when not allowed → expect revert.

- **Example commands**
  - Run the forked tests:
    - `forge test -vv --fork-url $MAINNET_RPC_URL`
  - Run a specific test file:
    - `forge test -vv --fork-url $MAINNET_RPC_URL --match-path test/LeverFork.t.sol`

### Deployment script — Lever Factory and auxiliaries

We ship a dedicated Foundry script that deploys the Lever Factory and wires fee plumbing and treasury. It should be deterministic, idempotent where possible, and environment-driven.

- **Script location**

  - `script/DeployLeverFactory.s.sol`

- **Environment variables**

  - `PRIVATE_KEY`: deployer key
  - `RPC_URL`: broadcast network RPC
  - `LEVER_TREASURY`: treasury recipient address (fallback to deployer if unset)

- `STAKER_REWARDS`: rewards contract address (optional, deploy in-script if empty)

  - `POOL_MANAGER`: `IPoolManager` address
  - `CLANKER_HOOK` (optional): if needed for init/open pool paths
  - `KEEPER`: address authorized to call harvester
  - `TREASURY_SPLIT_BPS`: basis points for rewards split
  - `PROTOCOL_FEES_JSON` (optional): JSON mapping `PoolKey` → fee to set post-deploy

- **Script steps**

  1. Load env; start broadcast.
  2. Deploy `Lever`, `LeverTreasury`, `Locker`, `WrappedToken`, `StakerRewards` (if not provided), `LeverFeeController`, `ProtocolFeeHarvester`.
  3. Wire roles and parameters: set treasury recipients, keeper, splits, pausers; set `Locker` as MINTER/BURNER on `WrappedToken`.
  4. Point `IPoolManager.setProtocolFeeController(LeverFeeController)`; set default per‑pool protocol fees.
  5. If `PROTOCOL_FEES_JSON` provided, iterate and `setProtocolFee` for each `PoolKey`.
  6. Emit addresses and write a summary (console logs are sufficient; optionally write to a JSON artifact).
  7. Stop broadcast.

- **Usage examples**
  - Dry run:
    - `forge script script/DeployLeverFactory.s.sol --rpc-url $RPC_URL --private-key $PRIVATE_KEY`
  - Broadcast:
    - `forge script script/DeployLeverFactory.s.sol --rpc-url $RPC_URL --private-key $PRIVATE_KEY --broadcast`

### Checklists

- **Pre-deploy**

  - Verify `IPoolManager` address and governance permissions to set protocol fee controller
  - Prepare recipient addresses, splits, keeper, and pauser roles
  - Prepare optional pools list and target fee bps

- **Post-deploy**
  - Confirm controller set on manager; verify per-pool fees
  - Run a small swap to accrue fees; harvest and verify treasury balances
  - Test pause/unpause and keeper-only paths

### Notes & constraints

- Respect `currency0 < currency1` ordering for any new pool inits and validate tick spacing bounds.
- Enforce protocol fee and dynamic fee caps as defined by Clanker hook interfaces.
- Keep `afterSwap` extension logic minimal; perform heavy operations via keeper/harvester.
- `Locker` + `WrappedToken` are mandatory components in Lever deployments.

### Wrapper full‑control mode (opt‑in)

- Purpose: allow governance to repurpose the wrapped token beyond strict 1:1 custody.
- Default: off. Only `Locker` has MINTER/BURNER; mint/burn only via deposits/withdrawals.
- Enabling (recommended pattern):
  - Pause during the switch; verify `totalSupply(WrappedToken)` == `Locker.escrowedBalance()`.
  - Two‑step/timelocked call: `enableFullControl(newController)` emits event and sets `fullControlEnabled = true`.
  - Grant MINTER/BURNER to `newController` while KEEPING `Locker` MINTER/BURNER active (concurrent authorities). Emit granular role events.
  - Optionally add per‑authority mint caps/rate limits.
- Clanker considerations: if the wrapped token is in a pool, switching to full control changes its economic guarantees; consider pausing pools, publishing notice, or migrating liquidity.

#### Redemption under shortfall (FIFO semantics)

- Keep redemption open with first‑come‑first‑serve semantics.
- If `escrowed < totalSupply`, process redemptions up to available escrow; remaining requests are either reverted or queued based on implementation policy.
- Recommended: redemption queue with per‑request timestamp and partial fill support; optional auto‑pause when shortfall exceeds a threshold; transparent events for fills/shortfalls.
